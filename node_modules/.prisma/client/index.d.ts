
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model MediaPreview
 * 
 */
export type MediaPreview = $Result.DefaultSelection<Prisma.$MediaPreviewPayload>
/**
 * Model UserQuota
 * 
 */
export type UserQuota = $Result.DefaultSelection<Prisma.$UserQuotaPayload>
/**
 * Model MediaCategory
 * 
 */
export type MediaCategory = $Result.DefaultSelection<Prisma.$MediaCategoryPayload>
/**
 * Model MediaAccessLog
 * 
 */
export type MediaAccessLog = $Result.DefaultSelection<Prisma.$MediaAccessLogPayload>
/**
 * Model MediaShare
 * 
 */
export type MediaShare = $Result.DefaultSelection<Prisma.$MediaSharePayload>
/**
 * Model ModerationHash
 * 
 */
export type ModerationHash = $Result.DefaultSelection<Prisma.$ModerationHashPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Media
 * const media = await prisma.media.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Media
   * const media = await prisma.media.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.mediaPreview`: Exposes CRUD operations for the **MediaPreview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaPreviews
    * const mediaPreviews = await prisma.mediaPreview.findMany()
    * ```
    */
  get mediaPreview(): Prisma.MediaPreviewDelegate<ExtArgs>;

  /**
   * `prisma.userQuota`: Exposes CRUD operations for the **UserQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQuotas
    * const userQuotas = await prisma.userQuota.findMany()
    * ```
    */
  get userQuota(): Prisma.UserQuotaDelegate<ExtArgs>;

  /**
   * `prisma.mediaCategory`: Exposes CRUD operations for the **MediaCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaCategories
    * const mediaCategories = await prisma.mediaCategory.findMany()
    * ```
    */
  get mediaCategory(): Prisma.MediaCategoryDelegate<ExtArgs>;

  /**
   * `prisma.mediaAccessLog`: Exposes CRUD operations for the **MediaAccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaAccessLogs
    * const mediaAccessLogs = await prisma.mediaAccessLog.findMany()
    * ```
    */
  get mediaAccessLog(): Prisma.MediaAccessLogDelegate<ExtArgs>;

  /**
   * `prisma.mediaShare`: Exposes CRUD operations for the **MediaShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaShares
    * const mediaShares = await prisma.mediaShare.findMany()
    * ```
    */
  get mediaShare(): Prisma.MediaShareDelegate<ExtArgs>;

  /**
   * `prisma.moderationHash`: Exposes CRUD operations for the **ModerationHash** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationHashes
    * const moderationHashes = await prisma.moderationHash.findMany()
    * ```
    */
  get moderationHash(): Prisma.ModerationHashDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Media: 'Media',
    MediaPreview: 'MediaPreview',
    UserQuota: 'UserQuota',
    MediaCategory: 'MediaCategory',
    MediaAccessLog: 'MediaAccessLog',
    MediaShare: 'MediaShare',
    ModerationHash: 'ModerationHash'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "media" | "mediaPreview" | "userQuota" | "mediaCategory" | "mediaAccessLog" | "mediaShare" | "moderationHash"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      MediaPreview: {
        payload: Prisma.$MediaPreviewPayload<ExtArgs>
        fields: Prisma.MediaPreviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaPreviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaPreviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload>
          }
          findFirst: {
            args: Prisma.MediaPreviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaPreviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload>
          }
          findMany: {
            args: Prisma.MediaPreviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload>[]
          }
          create: {
            args: Prisma.MediaPreviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload>
          }
          createMany: {
            args: Prisma.MediaPreviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaPreviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload>[]
          }
          delete: {
            args: Prisma.MediaPreviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload>
          }
          update: {
            args: Prisma.MediaPreviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload>
          }
          deleteMany: {
            args: Prisma.MediaPreviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaPreviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaPreviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPreviewPayload>
          }
          aggregate: {
            args: Prisma.MediaPreviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaPreview>
          }
          groupBy: {
            args: Prisma.MediaPreviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaPreviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaPreviewCountArgs<ExtArgs>
            result: $Utils.Optional<MediaPreviewCountAggregateOutputType> | number
          }
        }
      }
      UserQuota: {
        payload: Prisma.$UserQuotaPayload<ExtArgs>
        fields: Prisma.UserQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          findFirst: {
            args: Prisma.UserQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          findMany: {
            args: Prisma.UserQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>[]
          }
          create: {
            args: Prisma.UserQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          createMany: {
            args: Prisma.UserQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>[]
          }
          delete: {
            args: Prisma.UserQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          update: {
            args: Prisma.UserQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          deleteMany: {
            args: Prisma.UserQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuotaPayload>
          }
          aggregate: {
            args: Prisma.UserQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserQuota>
          }
          groupBy: {
            args: Prisma.UserQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<UserQuotaCountAggregateOutputType> | number
          }
        }
      }
      MediaCategory: {
        payload: Prisma.$MediaCategoryPayload<ExtArgs>
        fields: Prisma.MediaCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload>
          }
          findFirst: {
            args: Prisma.MediaCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload>
          }
          findMany: {
            args: Prisma.MediaCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload>[]
          }
          create: {
            args: Prisma.MediaCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload>
          }
          createMany: {
            args: Prisma.MediaCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload>[]
          }
          delete: {
            args: Prisma.MediaCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload>
          }
          update: {
            args: Prisma.MediaCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload>
          }
          deleteMany: {
            args: Prisma.MediaCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaCategoryPayload>
          }
          aggregate: {
            args: Prisma.MediaCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaCategory>
          }
          groupBy: {
            args: Prisma.MediaCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCategoryCountAggregateOutputType> | number
          }
        }
      }
      MediaAccessLog: {
        payload: Prisma.$MediaAccessLogPayload<ExtArgs>
        fields: Prisma.MediaAccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaAccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaAccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload>
          }
          findFirst: {
            args: Prisma.MediaAccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaAccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload>
          }
          findMany: {
            args: Prisma.MediaAccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload>[]
          }
          create: {
            args: Prisma.MediaAccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload>
          }
          createMany: {
            args: Prisma.MediaAccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaAccessLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload>[]
          }
          delete: {
            args: Prisma.MediaAccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload>
          }
          update: {
            args: Prisma.MediaAccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload>
          }
          deleteMany: {
            args: Prisma.MediaAccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaAccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaAccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAccessLogPayload>
          }
          aggregate: {
            args: Prisma.MediaAccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaAccessLog>
          }
          groupBy: {
            args: Prisma.MediaAccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaAccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaAccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<MediaAccessLogCountAggregateOutputType> | number
          }
        }
      }
      MediaShare: {
        payload: Prisma.$MediaSharePayload<ExtArgs>
        fields: Prisma.MediaShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload>
          }
          findFirst: {
            args: Prisma.MediaShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload>
          }
          findMany: {
            args: Prisma.MediaShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload>[]
          }
          create: {
            args: Prisma.MediaShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload>
          }
          createMany: {
            args: Prisma.MediaShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload>[]
          }
          delete: {
            args: Prisma.MediaShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload>
          }
          update: {
            args: Prisma.MediaShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload>
          }
          deleteMany: {
            args: Prisma.MediaShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSharePayload>
          }
          aggregate: {
            args: Prisma.MediaShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaShare>
          }
          groupBy: {
            args: Prisma.MediaShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaShareCountArgs<ExtArgs>
            result: $Utils.Optional<MediaShareCountAggregateOutputType> | number
          }
        }
      }
      ModerationHash: {
        payload: Prisma.$ModerationHashPayload<ExtArgs>
        fields: Prisma.ModerationHashFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationHashFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationHashFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload>
          }
          findFirst: {
            args: Prisma.ModerationHashFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationHashFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload>
          }
          findMany: {
            args: Prisma.ModerationHashFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload>[]
          }
          create: {
            args: Prisma.ModerationHashCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload>
          }
          createMany: {
            args: Prisma.ModerationHashCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModerationHashCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload>[]
          }
          delete: {
            args: Prisma.ModerationHashDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload>
          }
          update: {
            args: Prisma.ModerationHashUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload>
          }
          deleteMany: {
            args: Prisma.ModerationHashDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationHashUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModerationHashUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationHashPayload>
          }
          aggregate: {
            args: Prisma.ModerationHashAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModerationHash>
          }
          groupBy: {
            args: Prisma.ModerationHashGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModerationHashGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationHashCountArgs<ExtArgs>
            result: $Utils.Optional<ModerationHashCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    previews: number
    accessLogs: number
    shares: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    previews?: boolean | MediaCountOutputTypeCountPreviewsArgs
    accessLogs?: boolean | MediaCountOutputTypeCountAccessLogsArgs
    shares?: boolean | MediaCountOutputTypeCountSharesArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountPreviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaPreviewWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountAccessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAccessLogWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaShareWhereInput
  }


  /**
   * Count Type MediaCategoryCountOutputType
   */

  export type MediaCategoryCountOutputType = {
    media: number
  }

  export type MediaCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaCategoryCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * MediaCategoryCountOutputType without action
   */
  export type MediaCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategoryCountOutputType
     */
    select?: MediaCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCategoryCountOutputType without action
   */
  export type MediaCategoryCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type MediaSumAggregateOutputType = {
    fileSize: bigint | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    conversationId: string | null
    messageId: string | null
    originalFilename: string | null
    contentType: string | null
    fileSize: bigint | null
    storagePath: string | null
    encryptionKeyHash: string | null
    moderationHash: string | null
    categoryId: string | null
    isCompressed: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    conversationId: string | null
    messageId: string | null
    originalFilename: string | null
    contentType: string | null
    fileSize: bigint | null
    storagePath: string | null
    encryptionKeyHash: string | null
    moderationHash: string | null
    categoryId: string | null
    isCompressed: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    userId: number
    conversationId: number
    messageId: number
    originalFilename: number
    contentType: number
    fileSize: number
    storagePath: number
    encryptionKeyHash: number
    moderationHash: number
    categoryId: number
    metadata: number
    exifData: number
    isCompressed: number
    isActive: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    fileSize?: true
  }

  export type MediaSumAggregateInputType = {
    fileSize?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    userId?: true
    conversationId?: true
    messageId?: true
    originalFilename?: true
    contentType?: true
    fileSize?: true
    storagePath?: true
    encryptionKeyHash?: true
    moderationHash?: true
    categoryId?: true
    isCompressed?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    userId?: true
    conversationId?: true
    messageId?: true
    originalFilename?: true
    contentType?: true
    fileSize?: true
    storagePath?: true
    encryptionKeyHash?: true
    moderationHash?: true
    categoryId?: true
    isCompressed?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    userId?: true
    conversationId?: true
    messageId?: true
    originalFilename?: true
    contentType?: true
    fileSize?: true
    storagePath?: true
    encryptionKeyHash?: true
    moderationHash?: true
    categoryId?: true
    metadata?: true
    exifData?: true
    isCompressed?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    userId: string
    conversationId: string | null
    messageId: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    categoryId: string
    metadata: JsonValue
    exifData: JsonValue
    isCompressed: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    expiresAt: Date | null
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    conversationId?: boolean
    messageId?: boolean
    originalFilename?: boolean
    contentType?: boolean
    fileSize?: boolean
    storagePath?: boolean
    encryptionKeyHash?: boolean
    moderationHash?: boolean
    categoryId?: boolean
    metadata?: boolean
    exifData?: boolean
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    category?: boolean | MediaCategoryDefaultArgs<ExtArgs>
    previews?: boolean | Media$previewsArgs<ExtArgs>
    accessLogs?: boolean | Media$accessLogsArgs<ExtArgs>
    shares?: boolean | Media$sharesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    conversationId?: boolean
    messageId?: boolean
    originalFilename?: boolean
    contentType?: boolean
    fileSize?: boolean
    storagePath?: boolean
    encryptionKeyHash?: boolean
    moderationHash?: boolean
    categoryId?: boolean
    metadata?: boolean
    exifData?: boolean
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    category?: boolean | MediaCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    userId?: boolean
    conversationId?: boolean
    messageId?: boolean
    originalFilename?: boolean
    contentType?: boolean
    fileSize?: boolean
    storagePath?: boolean
    encryptionKeyHash?: boolean
    moderationHash?: boolean
    categoryId?: boolean
    metadata?: boolean
    exifData?: boolean
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | MediaCategoryDefaultArgs<ExtArgs>
    previews?: boolean | Media$previewsArgs<ExtArgs>
    accessLogs?: boolean | Media$accessLogsArgs<ExtArgs>
    shares?: boolean | Media$sharesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | MediaCategoryDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      category: Prisma.$MediaCategoryPayload<ExtArgs>
      previews: Prisma.$MediaPreviewPayload<ExtArgs>[]
      accessLogs: Prisma.$MediaAccessLogPayload<ExtArgs>[]
      shares: Prisma.$MediaSharePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      conversationId: string | null
      messageId: string | null
      originalFilename: string
      contentType: string
      fileSize: bigint
      storagePath: string
      encryptionKeyHash: string
      moderationHash: string
      categoryId: string
      metadata: Prisma.JsonValue
      exifData: Prisma.JsonValue
      isCompressed: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends MediaCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaCategoryDefaultArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    previews<T extends Media$previewsArgs<ExtArgs> = {}>(args?: Subset<T, Media$previewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "findMany"> | Null>
    accessLogs<T extends Media$accessLogsArgs<ExtArgs> = {}>(args?: Subset<T, Media$accessLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "findMany"> | Null>
    shares<T extends Media$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Media$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly userId: FieldRef<"Media", 'String'>
    readonly conversationId: FieldRef<"Media", 'String'>
    readonly messageId: FieldRef<"Media", 'String'>
    readonly originalFilename: FieldRef<"Media", 'String'>
    readonly contentType: FieldRef<"Media", 'String'>
    readonly fileSize: FieldRef<"Media", 'BigInt'>
    readonly storagePath: FieldRef<"Media", 'String'>
    readonly encryptionKeyHash: FieldRef<"Media", 'String'>
    readonly moderationHash: FieldRef<"Media", 'String'>
    readonly categoryId: FieldRef<"Media", 'String'>
    readonly metadata: FieldRef<"Media", 'Json'>
    readonly exifData: FieldRef<"Media", 'Json'>
    readonly isCompressed: FieldRef<"Media", 'Boolean'>
    readonly isActive: FieldRef<"Media", 'Boolean'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
    readonly expiresAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media.previews
   */
  export type Media$previewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    where?: MediaPreviewWhereInput
    orderBy?: MediaPreviewOrderByWithRelationInput | MediaPreviewOrderByWithRelationInput[]
    cursor?: MediaPreviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaPreviewScalarFieldEnum | MediaPreviewScalarFieldEnum[]
  }

  /**
   * Media.accessLogs
   */
  export type Media$accessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    where?: MediaAccessLogWhereInput
    orderBy?: MediaAccessLogOrderByWithRelationInput | MediaAccessLogOrderByWithRelationInput[]
    cursor?: MediaAccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaAccessLogScalarFieldEnum | MediaAccessLogScalarFieldEnum[]
  }

  /**
   * Media.shares
   */
  export type Media$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    where?: MediaShareWhereInput
    orderBy?: MediaShareOrderByWithRelationInput | MediaShareOrderByWithRelationInput[]
    cursor?: MediaShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaShareScalarFieldEnum | MediaShareScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model MediaPreview
   */

  export type AggregateMediaPreview = {
    _count: MediaPreviewCountAggregateOutputType | null
    _avg: MediaPreviewAvgAggregateOutputType | null
    _sum: MediaPreviewSumAggregateOutputType | null
    _min: MediaPreviewMinAggregateOutputType | null
    _max: MediaPreviewMaxAggregateOutputType | null
  }

  export type MediaPreviewAvgAggregateOutputType = {
    width: number | null
    height: number | null
    fileSize: number | null
  }

  export type MediaPreviewSumAggregateOutputType = {
    width: number | null
    height: number | null
    fileSize: bigint | null
  }

  export type MediaPreviewMinAggregateOutputType = {
    id: string | null
    mediaId: string | null
    previewType: string | null
    storagePath: string | null
    contentType: string | null
    width: number | null
    height: number | null
    fileSize: bigint | null
    createdAt: Date | null
  }

  export type MediaPreviewMaxAggregateOutputType = {
    id: string | null
    mediaId: string | null
    previewType: string | null
    storagePath: string | null
    contentType: string | null
    width: number | null
    height: number | null
    fileSize: bigint | null
    createdAt: Date | null
  }

  export type MediaPreviewCountAggregateOutputType = {
    id: number
    mediaId: number
    previewType: number
    storagePath: number
    contentType: number
    width: number
    height: number
    fileSize: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type MediaPreviewAvgAggregateInputType = {
    width?: true
    height?: true
    fileSize?: true
  }

  export type MediaPreviewSumAggregateInputType = {
    width?: true
    height?: true
    fileSize?: true
  }

  export type MediaPreviewMinAggregateInputType = {
    id?: true
    mediaId?: true
    previewType?: true
    storagePath?: true
    contentType?: true
    width?: true
    height?: true
    fileSize?: true
    createdAt?: true
  }

  export type MediaPreviewMaxAggregateInputType = {
    id?: true
    mediaId?: true
    previewType?: true
    storagePath?: true
    contentType?: true
    width?: true
    height?: true
    fileSize?: true
    createdAt?: true
  }

  export type MediaPreviewCountAggregateInputType = {
    id?: true
    mediaId?: true
    previewType?: true
    storagePath?: true
    contentType?: true
    width?: true
    height?: true
    fileSize?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type MediaPreviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaPreview to aggregate.
     */
    where?: MediaPreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPreviews to fetch.
     */
    orderBy?: MediaPreviewOrderByWithRelationInput | MediaPreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaPreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaPreviews
    **/
    _count?: true | MediaPreviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaPreviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaPreviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaPreviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaPreviewMaxAggregateInputType
  }

  export type GetMediaPreviewAggregateType<T extends MediaPreviewAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaPreview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaPreview[P]>
      : GetScalarType<T[P], AggregateMediaPreview[P]>
  }




  export type MediaPreviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaPreviewWhereInput
    orderBy?: MediaPreviewOrderByWithAggregationInput | MediaPreviewOrderByWithAggregationInput[]
    by: MediaPreviewScalarFieldEnum[] | MediaPreviewScalarFieldEnum
    having?: MediaPreviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaPreviewCountAggregateInputType | true
    _avg?: MediaPreviewAvgAggregateInputType
    _sum?: MediaPreviewSumAggregateInputType
    _min?: MediaPreviewMinAggregateInputType
    _max?: MediaPreviewMaxAggregateInputType
  }

  export type MediaPreviewGroupByOutputType = {
    id: string
    mediaId: string
    previewType: string
    storagePath: string
    contentType: string
    width: number | null
    height: number | null
    fileSize: bigint
    metadata: JsonValue
    createdAt: Date
    _count: MediaPreviewCountAggregateOutputType | null
    _avg: MediaPreviewAvgAggregateOutputType | null
    _sum: MediaPreviewSumAggregateOutputType | null
    _min: MediaPreviewMinAggregateOutputType | null
    _max: MediaPreviewMaxAggregateOutputType | null
  }

  type GetMediaPreviewGroupByPayload<T extends MediaPreviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaPreviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaPreviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaPreviewGroupByOutputType[P]>
            : GetScalarType<T[P], MediaPreviewGroupByOutputType[P]>
        }
      >
    >


  export type MediaPreviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaId?: boolean
    previewType?: boolean
    storagePath?: boolean
    contentType?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    metadata?: boolean
    createdAt?: boolean
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaPreview"]>

  export type MediaPreviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaId?: boolean
    previewType?: boolean
    storagePath?: boolean
    contentType?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    metadata?: boolean
    createdAt?: boolean
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaPreview"]>

  export type MediaPreviewSelectScalar = {
    id?: boolean
    mediaId?: boolean
    previewType?: boolean
    storagePath?: boolean
    contentType?: boolean
    width?: boolean
    height?: boolean
    fileSize?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type MediaPreviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type MediaPreviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $MediaPreviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaPreview"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mediaId: string
      previewType: string
      storagePath: string
      contentType: string
      width: number | null
      height: number | null
      fileSize: bigint
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["mediaPreview"]>
    composites: {}
  }

  type MediaPreviewGetPayload<S extends boolean | null | undefined | MediaPreviewDefaultArgs> = $Result.GetResult<Prisma.$MediaPreviewPayload, S>

  type MediaPreviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaPreviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaPreviewCountAggregateInputType | true
    }

  export interface MediaPreviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaPreview'], meta: { name: 'MediaPreview' } }
    /**
     * Find zero or one MediaPreview that matches the filter.
     * @param {MediaPreviewFindUniqueArgs} args - Arguments to find a MediaPreview
     * @example
     * // Get one MediaPreview
     * const mediaPreview = await prisma.mediaPreview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaPreviewFindUniqueArgs>(args: SelectSubset<T, MediaPreviewFindUniqueArgs<ExtArgs>>): Prisma__MediaPreviewClient<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaPreview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaPreviewFindUniqueOrThrowArgs} args - Arguments to find a MediaPreview
     * @example
     * // Get one MediaPreview
     * const mediaPreview = await prisma.mediaPreview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaPreviewFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaPreviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaPreviewClient<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaPreview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPreviewFindFirstArgs} args - Arguments to find a MediaPreview
     * @example
     * // Get one MediaPreview
     * const mediaPreview = await prisma.mediaPreview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaPreviewFindFirstArgs>(args?: SelectSubset<T, MediaPreviewFindFirstArgs<ExtArgs>>): Prisma__MediaPreviewClient<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaPreview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPreviewFindFirstOrThrowArgs} args - Arguments to find a MediaPreview
     * @example
     * // Get one MediaPreview
     * const mediaPreview = await prisma.mediaPreview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaPreviewFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaPreviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaPreviewClient<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaPreviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPreviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaPreviews
     * const mediaPreviews = await prisma.mediaPreview.findMany()
     * 
     * // Get first 10 MediaPreviews
     * const mediaPreviews = await prisma.mediaPreview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaPreviewWithIdOnly = await prisma.mediaPreview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaPreviewFindManyArgs>(args?: SelectSubset<T, MediaPreviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaPreview.
     * @param {MediaPreviewCreateArgs} args - Arguments to create a MediaPreview.
     * @example
     * // Create one MediaPreview
     * const MediaPreview = await prisma.mediaPreview.create({
     *   data: {
     *     // ... data to create a MediaPreview
     *   }
     * })
     * 
     */
    create<T extends MediaPreviewCreateArgs>(args: SelectSubset<T, MediaPreviewCreateArgs<ExtArgs>>): Prisma__MediaPreviewClient<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaPreviews.
     * @param {MediaPreviewCreateManyArgs} args - Arguments to create many MediaPreviews.
     * @example
     * // Create many MediaPreviews
     * const mediaPreview = await prisma.mediaPreview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaPreviewCreateManyArgs>(args?: SelectSubset<T, MediaPreviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaPreviews and returns the data saved in the database.
     * @param {MediaPreviewCreateManyAndReturnArgs} args - Arguments to create many MediaPreviews.
     * @example
     * // Create many MediaPreviews
     * const mediaPreview = await prisma.mediaPreview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaPreviews and only return the `id`
     * const mediaPreviewWithIdOnly = await prisma.mediaPreview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaPreviewCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaPreviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaPreview.
     * @param {MediaPreviewDeleteArgs} args - Arguments to delete one MediaPreview.
     * @example
     * // Delete one MediaPreview
     * const MediaPreview = await prisma.mediaPreview.delete({
     *   where: {
     *     // ... filter to delete one MediaPreview
     *   }
     * })
     * 
     */
    delete<T extends MediaPreviewDeleteArgs>(args: SelectSubset<T, MediaPreviewDeleteArgs<ExtArgs>>): Prisma__MediaPreviewClient<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaPreview.
     * @param {MediaPreviewUpdateArgs} args - Arguments to update one MediaPreview.
     * @example
     * // Update one MediaPreview
     * const mediaPreview = await prisma.mediaPreview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaPreviewUpdateArgs>(args: SelectSubset<T, MediaPreviewUpdateArgs<ExtArgs>>): Prisma__MediaPreviewClient<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaPreviews.
     * @param {MediaPreviewDeleteManyArgs} args - Arguments to filter MediaPreviews to delete.
     * @example
     * // Delete a few MediaPreviews
     * const { count } = await prisma.mediaPreview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaPreviewDeleteManyArgs>(args?: SelectSubset<T, MediaPreviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaPreviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPreviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaPreviews
     * const mediaPreview = await prisma.mediaPreview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaPreviewUpdateManyArgs>(args: SelectSubset<T, MediaPreviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaPreview.
     * @param {MediaPreviewUpsertArgs} args - Arguments to update or create a MediaPreview.
     * @example
     * // Update or create a MediaPreview
     * const mediaPreview = await prisma.mediaPreview.upsert({
     *   create: {
     *     // ... data to create a MediaPreview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaPreview we want to update
     *   }
     * })
     */
    upsert<T extends MediaPreviewUpsertArgs>(args: SelectSubset<T, MediaPreviewUpsertArgs<ExtArgs>>): Prisma__MediaPreviewClient<$Result.GetResult<Prisma.$MediaPreviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaPreviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPreviewCountArgs} args - Arguments to filter MediaPreviews to count.
     * @example
     * // Count the number of MediaPreviews
     * const count = await prisma.mediaPreview.count({
     *   where: {
     *     // ... the filter for the MediaPreviews we want to count
     *   }
     * })
    **/
    count<T extends MediaPreviewCountArgs>(
      args?: Subset<T, MediaPreviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaPreviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaPreview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPreviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaPreviewAggregateArgs>(args: Subset<T, MediaPreviewAggregateArgs>): Prisma.PrismaPromise<GetMediaPreviewAggregateType<T>>

    /**
     * Group by MediaPreview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPreviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaPreviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaPreviewGroupByArgs['orderBy'] }
        : { orderBy?: MediaPreviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaPreviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaPreviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaPreview model
   */
  readonly fields: MediaPreviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaPreview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaPreviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaPreview model
   */ 
  interface MediaPreviewFieldRefs {
    readonly id: FieldRef<"MediaPreview", 'String'>
    readonly mediaId: FieldRef<"MediaPreview", 'String'>
    readonly previewType: FieldRef<"MediaPreview", 'String'>
    readonly storagePath: FieldRef<"MediaPreview", 'String'>
    readonly contentType: FieldRef<"MediaPreview", 'String'>
    readonly width: FieldRef<"MediaPreview", 'Int'>
    readonly height: FieldRef<"MediaPreview", 'Int'>
    readonly fileSize: FieldRef<"MediaPreview", 'BigInt'>
    readonly metadata: FieldRef<"MediaPreview", 'Json'>
    readonly createdAt: FieldRef<"MediaPreview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaPreview findUnique
   */
  export type MediaPreviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * Filter, which MediaPreview to fetch.
     */
    where: MediaPreviewWhereUniqueInput
  }

  /**
   * MediaPreview findUniqueOrThrow
   */
  export type MediaPreviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * Filter, which MediaPreview to fetch.
     */
    where: MediaPreviewWhereUniqueInput
  }

  /**
   * MediaPreview findFirst
   */
  export type MediaPreviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * Filter, which MediaPreview to fetch.
     */
    where?: MediaPreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPreviews to fetch.
     */
    orderBy?: MediaPreviewOrderByWithRelationInput | MediaPreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaPreviews.
     */
    cursor?: MediaPreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaPreviews.
     */
    distinct?: MediaPreviewScalarFieldEnum | MediaPreviewScalarFieldEnum[]
  }

  /**
   * MediaPreview findFirstOrThrow
   */
  export type MediaPreviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * Filter, which MediaPreview to fetch.
     */
    where?: MediaPreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPreviews to fetch.
     */
    orderBy?: MediaPreviewOrderByWithRelationInput | MediaPreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaPreviews.
     */
    cursor?: MediaPreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaPreviews.
     */
    distinct?: MediaPreviewScalarFieldEnum | MediaPreviewScalarFieldEnum[]
  }

  /**
   * MediaPreview findMany
   */
  export type MediaPreviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * Filter, which MediaPreviews to fetch.
     */
    where?: MediaPreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPreviews to fetch.
     */
    orderBy?: MediaPreviewOrderByWithRelationInput | MediaPreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaPreviews.
     */
    cursor?: MediaPreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPreviews.
     */
    skip?: number
    distinct?: MediaPreviewScalarFieldEnum | MediaPreviewScalarFieldEnum[]
  }

  /**
   * MediaPreview create
   */
  export type MediaPreviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaPreview.
     */
    data: XOR<MediaPreviewCreateInput, MediaPreviewUncheckedCreateInput>
  }

  /**
   * MediaPreview createMany
   */
  export type MediaPreviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaPreviews.
     */
    data: MediaPreviewCreateManyInput | MediaPreviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaPreview createManyAndReturn
   */
  export type MediaPreviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaPreviews.
     */
    data: MediaPreviewCreateManyInput | MediaPreviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaPreview update
   */
  export type MediaPreviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaPreview.
     */
    data: XOR<MediaPreviewUpdateInput, MediaPreviewUncheckedUpdateInput>
    /**
     * Choose, which MediaPreview to update.
     */
    where: MediaPreviewWhereUniqueInput
  }

  /**
   * MediaPreview updateMany
   */
  export type MediaPreviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaPreviews.
     */
    data: XOR<MediaPreviewUpdateManyMutationInput, MediaPreviewUncheckedUpdateManyInput>
    /**
     * Filter which MediaPreviews to update
     */
    where?: MediaPreviewWhereInput
  }

  /**
   * MediaPreview upsert
   */
  export type MediaPreviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaPreview to update in case it exists.
     */
    where: MediaPreviewWhereUniqueInput
    /**
     * In case the MediaPreview found by the `where` argument doesn't exist, create a new MediaPreview with this data.
     */
    create: XOR<MediaPreviewCreateInput, MediaPreviewUncheckedCreateInput>
    /**
     * In case the MediaPreview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaPreviewUpdateInput, MediaPreviewUncheckedUpdateInput>
  }

  /**
   * MediaPreview delete
   */
  export type MediaPreviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
    /**
     * Filter which MediaPreview to delete.
     */
    where: MediaPreviewWhereUniqueInput
  }

  /**
   * MediaPreview deleteMany
   */
  export type MediaPreviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaPreviews to delete
     */
    where?: MediaPreviewWhereInput
  }

  /**
   * MediaPreview without action
   */
  export type MediaPreviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPreview
     */
    select?: MediaPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPreviewInclude<ExtArgs> | null
  }


  /**
   * Model UserQuota
   */

  export type AggregateUserQuota = {
    _count: UserQuotaCountAggregateOutputType | null
    _avg: UserQuotaAvgAggregateOutputType | null
    _sum: UserQuotaSumAggregateOutputType | null
    _min: UserQuotaMinAggregateOutputType | null
    _max: UserQuotaMaxAggregateOutputType | null
  }

  export type UserQuotaAvgAggregateOutputType = {
    storageUsed: number | null
    storageLimit: number | null
    filesCount: number | null
    filesLimit: number | null
    dailyUploads: number | null
    dailyUploadLimit: number | null
  }

  export type UserQuotaSumAggregateOutputType = {
    storageUsed: bigint | null
    storageLimit: bigint | null
    filesCount: number | null
    filesLimit: number | null
    dailyUploads: number | null
    dailyUploadLimit: number | null
  }

  export type UserQuotaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    storageUsed: bigint | null
    storageLimit: bigint | null
    filesCount: number | null
    filesLimit: number | null
    dailyUploads: number | null
    dailyUploadLimit: number | null
    quotaDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserQuotaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    storageUsed: bigint | null
    storageLimit: bigint | null
    filesCount: number | null
    filesLimit: number | null
    dailyUploads: number | null
    dailyUploadLimit: number | null
    quotaDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserQuotaCountAggregateOutputType = {
    id: number
    userId: number
    storageUsed: number
    storageLimit: number
    filesCount: number
    filesLimit: number
    dailyUploads: number
    dailyUploadLimit: number
    quotaDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserQuotaAvgAggregateInputType = {
    storageUsed?: true
    storageLimit?: true
    filesCount?: true
    filesLimit?: true
    dailyUploads?: true
    dailyUploadLimit?: true
  }

  export type UserQuotaSumAggregateInputType = {
    storageUsed?: true
    storageLimit?: true
    filesCount?: true
    filesLimit?: true
    dailyUploads?: true
    dailyUploadLimit?: true
  }

  export type UserQuotaMinAggregateInputType = {
    id?: true
    userId?: true
    storageUsed?: true
    storageLimit?: true
    filesCount?: true
    filesLimit?: true
    dailyUploads?: true
    dailyUploadLimit?: true
    quotaDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserQuotaMaxAggregateInputType = {
    id?: true
    userId?: true
    storageUsed?: true
    storageLimit?: true
    filesCount?: true
    filesLimit?: true
    dailyUploads?: true
    dailyUploadLimit?: true
    quotaDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserQuotaCountAggregateInputType = {
    id?: true
    userId?: true
    storageUsed?: true
    storageLimit?: true
    filesCount?: true
    filesLimit?: true
    dailyUploads?: true
    dailyUploadLimit?: true
    quotaDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuota to aggregate.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQuotas
    **/
    _count?: true | UserQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQuotaMaxAggregateInputType
  }

  export type GetUserQuotaAggregateType<T extends UserQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQuota[P]>
      : GetScalarType<T[P], AggregateUserQuota[P]>
  }




  export type UserQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuotaWhereInput
    orderBy?: UserQuotaOrderByWithAggregationInput | UserQuotaOrderByWithAggregationInput[]
    by: UserQuotaScalarFieldEnum[] | UserQuotaScalarFieldEnum
    having?: UserQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQuotaCountAggregateInputType | true
    _avg?: UserQuotaAvgAggregateInputType
    _sum?: UserQuotaSumAggregateInputType
    _min?: UserQuotaMinAggregateInputType
    _max?: UserQuotaMaxAggregateInputType
  }

  export type UserQuotaGroupByOutputType = {
    id: string
    userId: string
    storageUsed: bigint
    storageLimit: bigint
    filesCount: number
    filesLimit: number
    dailyUploads: number
    dailyUploadLimit: number
    quotaDate: Date
    createdAt: Date
    updatedAt: Date
    _count: UserQuotaCountAggregateOutputType | null
    _avg: UserQuotaAvgAggregateOutputType | null
    _sum: UserQuotaSumAggregateOutputType | null
    _min: UserQuotaMinAggregateOutputType | null
    _max: UserQuotaMaxAggregateOutputType | null
  }

  type GetUserQuotaGroupByPayload<T extends UserQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], UserQuotaGroupByOutputType[P]>
        }
      >
    >


  export type UserQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storageUsed?: boolean
    storageLimit?: boolean
    filesCount?: boolean
    filesLimit?: boolean
    dailyUploads?: boolean
    dailyUploadLimit?: boolean
    quotaDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userQuota"]>

  export type UserQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storageUsed?: boolean
    storageLimit?: boolean
    filesCount?: boolean
    filesLimit?: boolean
    dailyUploads?: boolean
    dailyUploadLimit?: boolean
    quotaDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userQuota"]>

  export type UserQuotaSelectScalar = {
    id?: boolean
    userId?: boolean
    storageUsed?: boolean
    storageLimit?: boolean
    filesCount?: boolean
    filesLimit?: boolean
    dailyUploads?: boolean
    dailyUploadLimit?: boolean
    quotaDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UserQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQuota"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      storageUsed: bigint
      storageLimit: bigint
      filesCount: number
      filesLimit: number
      dailyUploads: number
      dailyUploadLimit: number
      quotaDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userQuota"]>
    composites: {}
  }

  type UserQuotaGetPayload<S extends boolean | null | undefined | UserQuotaDefaultArgs> = $Result.GetResult<Prisma.$UserQuotaPayload, S>

  type UserQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserQuotaCountAggregateInputType | true
    }

  export interface UserQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQuota'], meta: { name: 'UserQuota' } }
    /**
     * Find zero or one UserQuota that matches the filter.
     * @param {UserQuotaFindUniqueArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserQuotaFindUniqueArgs>(args: SelectSubset<T, UserQuotaFindUniqueArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserQuotaFindUniqueOrThrowArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, UserQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindFirstArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserQuotaFindFirstArgs>(args?: SelectSubset<T, UserQuotaFindFirstArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindFirstOrThrowArgs} args - Arguments to find a UserQuota
     * @example
     * // Get one UserQuota
     * const userQuota = await prisma.userQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, UserQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQuotas
     * const userQuotas = await prisma.userQuota.findMany()
     * 
     * // Get first 10 UserQuotas
     * const userQuotas = await prisma.userQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userQuotaWithIdOnly = await prisma.userQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserQuotaFindManyArgs>(args?: SelectSubset<T, UserQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserQuota.
     * @param {UserQuotaCreateArgs} args - Arguments to create a UserQuota.
     * @example
     * // Create one UserQuota
     * const UserQuota = await prisma.userQuota.create({
     *   data: {
     *     // ... data to create a UserQuota
     *   }
     * })
     * 
     */
    create<T extends UserQuotaCreateArgs>(args: SelectSubset<T, UserQuotaCreateArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserQuotas.
     * @param {UserQuotaCreateManyArgs} args - Arguments to create many UserQuotas.
     * @example
     * // Create many UserQuotas
     * const userQuota = await prisma.userQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserQuotaCreateManyArgs>(args?: SelectSubset<T, UserQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserQuotas and returns the data saved in the database.
     * @param {UserQuotaCreateManyAndReturnArgs} args - Arguments to create many UserQuotas.
     * @example
     * // Create many UserQuotas
     * const userQuota = await prisma.userQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserQuotas and only return the `id`
     * const userQuotaWithIdOnly = await prisma.userQuota.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, UserQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserQuota.
     * @param {UserQuotaDeleteArgs} args - Arguments to delete one UserQuota.
     * @example
     * // Delete one UserQuota
     * const UserQuota = await prisma.userQuota.delete({
     *   where: {
     *     // ... filter to delete one UserQuota
     *   }
     * })
     * 
     */
    delete<T extends UserQuotaDeleteArgs>(args: SelectSubset<T, UserQuotaDeleteArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserQuota.
     * @param {UserQuotaUpdateArgs} args - Arguments to update one UserQuota.
     * @example
     * // Update one UserQuota
     * const userQuota = await prisma.userQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserQuotaUpdateArgs>(args: SelectSubset<T, UserQuotaUpdateArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserQuotas.
     * @param {UserQuotaDeleteManyArgs} args - Arguments to filter UserQuotas to delete.
     * @example
     * // Delete a few UserQuotas
     * const { count } = await prisma.userQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserQuotaDeleteManyArgs>(args?: SelectSubset<T, UserQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQuotas
     * const userQuota = await prisma.userQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserQuotaUpdateManyArgs>(args: SelectSubset<T, UserQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserQuota.
     * @param {UserQuotaUpsertArgs} args - Arguments to update or create a UserQuota.
     * @example
     * // Update or create a UserQuota
     * const userQuota = await prisma.userQuota.upsert({
     *   create: {
     *     // ... data to create a UserQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQuota we want to update
     *   }
     * })
     */
    upsert<T extends UserQuotaUpsertArgs>(args: SelectSubset<T, UserQuotaUpsertArgs<ExtArgs>>): Prisma__UserQuotaClient<$Result.GetResult<Prisma.$UserQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaCountArgs} args - Arguments to filter UserQuotas to count.
     * @example
     * // Count the number of UserQuotas
     * const count = await prisma.userQuota.count({
     *   where: {
     *     // ... the filter for the UserQuotas we want to count
     *   }
     * })
    **/
    count<T extends UserQuotaCountArgs>(
      args?: Subset<T, UserQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQuotaAggregateArgs>(args: Subset<T, UserQuotaAggregateArgs>): Prisma.PrismaPromise<GetUserQuotaAggregateType<T>>

    /**
     * Group by UserQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQuotaGroupByArgs['orderBy'] }
        : { orderBy?: UserQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQuota model
   */
  readonly fields: UserQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserQuota model
   */ 
  interface UserQuotaFieldRefs {
    readonly id: FieldRef<"UserQuota", 'String'>
    readonly userId: FieldRef<"UserQuota", 'String'>
    readonly storageUsed: FieldRef<"UserQuota", 'BigInt'>
    readonly storageLimit: FieldRef<"UserQuota", 'BigInt'>
    readonly filesCount: FieldRef<"UserQuota", 'Int'>
    readonly filesLimit: FieldRef<"UserQuota", 'Int'>
    readonly dailyUploads: FieldRef<"UserQuota", 'Int'>
    readonly dailyUploadLimit: FieldRef<"UserQuota", 'Int'>
    readonly quotaDate: FieldRef<"UserQuota", 'DateTime'>
    readonly createdAt: FieldRef<"UserQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"UserQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserQuota findUnique
   */
  export type UserQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota findUniqueOrThrow
   */
  export type UserQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota findFirst
   */
  export type UserQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuotas.
     */
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota findFirstOrThrow
   */
  export type UserQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Filter, which UserQuota to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuotas.
     */
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota findMany
   */
  export type UserQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Filter, which UserQuotas to fetch.
     */
    where?: UserQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuotas to fetch.
     */
    orderBy?: UserQuotaOrderByWithRelationInput | UserQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQuotas.
     */
    cursor?: UserQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuotas.
     */
    skip?: number
    distinct?: UserQuotaScalarFieldEnum | UserQuotaScalarFieldEnum[]
  }

  /**
   * UserQuota create
   */
  export type UserQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * The data needed to create a UserQuota.
     */
    data: XOR<UserQuotaCreateInput, UserQuotaUncheckedCreateInput>
  }

  /**
   * UserQuota createMany
   */
  export type UserQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQuotas.
     */
    data: UserQuotaCreateManyInput | UserQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQuota createManyAndReturn
   */
  export type UserQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserQuotas.
     */
    data: UserQuotaCreateManyInput | UserQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQuota update
   */
  export type UserQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * The data needed to update a UserQuota.
     */
    data: XOR<UserQuotaUpdateInput, UserQuotaUncheckedUpdateInput>
    /**
     * Choose, which UserQuota to update.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota updateMany
   */
  export type UserQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQuotas.
     */
    data: XOR<UserQuotaUpdateManyMutationInput, UserQuotaUncheckedUpdateManyInput>
    /**
     * Filter which UserQuotas to update
     */
    where?: UserQuotaWhereInput
  }

  /**
   * UserQuota upsert
   */
  export type UserQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * The filter to search for the UserQuota to update in case it exists.
     */
    where: UserQuotaWhereUniqueInput
    /**
     * In case the UserQuota found by the `where` argument doesn't exist, create a new UserQuota with this data.
     */
    create: XOR<UserQuotaCreateInput, UserQuotaUncheckedCreateInput>
    /**
     * In case the UserQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQuotaUpdateInput, UserQuotaUncheckedUpdateInput>
  }

  /**
   * UserQuota delete
   */
  export type UserQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
    /**
     * Filter which UserQuota to delete.
     */
    where: UserQuotaWhereUniqueInput
  }

  /**
   * UserQuota deleteMany
   */
  export type UserQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuotas to delete
     */
    where?: UserQuotaWhereInput
  }

  /**
   * UserQuota without action
   */
  export type UserQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuota
     */
    select?: UserQuotaSelect<ExtArgs> | null
  }


  /**
   * Model MediaCategory
   */

  export type AggregateMediaCategory = {
    _count: MediaCategoryCountAggregateOutputType | null
    _avg: MediaCategoryAvgAggregateOutputType | null
    _sum: MediaCategorySumAggregateOutputType | null
    _min: MediaCategoryMinAggregateOutputType | null
    _max: MediaCategoryMaxAggregateOutputType | null
  }

  export type MediaCategoryAvgAggregateOutputType = {
    maxFileSize: number | null
  }

  export type MediaCategorySumAggregateOutputType = {
    maxFileSize: bigint | null
  }

  export type MediaCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    maxFileSize: bigint | null
    compressionEnabled: boolean | null
    previewEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    maxFileSize: bigint | null
    compressionEnabled: boolean | null
    previewEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    allowedTypes: number
    maxFileSize: number
    compressionEnabled: number
    previewEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaCategoryAvgAggregateInputType = {
    maxFileSize?: true
  }

  export type MediaCategorySumAggregateInputType = {
    maxFileSize?: true
  }

  export type MediaCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    maxFileSize?: true
    compressionEnabled?: true
    previewEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    maxFileSize?: true
    compressionEnabled?: true
    previewEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    allowedTypes?: true
    maxFileSize?: true
    compressionEnabled?: true
    previewEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaCategory to aggregate.
     */
    where?: MediaCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaCategories to fetch.
     */
    orderBy?: MediaCategoryOrderByWithRelationInput | MediaCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaCategories
    **/
    _count?: true | MediaCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaCategoryMaxAggregateInputType
  }

  export type GetMediaCategoryAggregateType<T extends MediaCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaCategory[P]>
      : GetScalarType<T[P], AggregateMediaCategory[P]>
  }




  export type MediaCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaCategoryWhereInput
    orderBy?: MediaCategoryOrderByWithAggregationInput | MediaCategoryOrderByWithAggregationInput[]
    by: MediaCategoryScalarFieldEnum[] | MediaCategoryScalarFieldEnum
    having?: MediaCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCategoryCountAggregateInputType | true
    _avg?: MediaCategoryAvgAggregateInputType
    _sum?: MediaCategorySumAggregateInputType
    _min?: MediaCategoryMinAggregateInputType
    _max?: MediaCategoryMaxAggregateInputType
  }

  export type MediaCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    allowedTypes: JsonValue
    maxFileSize: bigint
    compressionEnabled: boolean
    previewEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: MediaCategoryCountAggregateOutputType | null
    _avg: MediaCategoryAvgAggregateOutputType | null
    _sum: MediaCategorySumAggregateOutputType | null
    _min: MediaCategoryMinAggregateOutputType | null
    _max: MediaCategoryMaxAggregateOutputType | null
  }

  type GetMediaCategoryGroupByPayload<T extends MediaCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], MediaCategoryGroupByOutputType[P]>
        }
      >
    >


  export type MediaCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    allowedTypes?: boolean
    maxFileSize?: boolean
    compressionEnabled?: boolean
    previewEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    media?: boolean | MediaCategory$mediaArgs<ExtArgs>
    _count?: boolean | MediaCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaCategory"]>

  export type MediaCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    allowedTypes?: boolean
    maxFileSize?: boolean
    compressionEnabled?: boolean
    previewEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mediaCategory"]>

  export type MediaCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    allowedTypes?: boolean
    maxFileSize?: boolean
    compressionEnabled?: boolean
    previewEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaCategory$mediaArgs<ExtArgs>
    _count?: boolean | MediaCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MediaCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaCategory"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      allowedTypes: Prisma.JsonValue
      maxFileSize: bigint
      compressionEnabled: boolean
      previewEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaCategory"]>
    composites: {}
  }

  type MediaCategoryGetPayload<S extends boolean | null | undefined | MediaCategoryDefaultArgs> = $Result.GetResult<Prisma.$MediaCategoryPayload, S>

  type MediaCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCategoryCountAggregateInputType | true
    }

  export interface MediaCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaCategory'], meta: { name: 'MediaCategory' } }
    /**
     * Find zero or one MediaCategory that matches the filter.
     * @param {MediaCategoryFindUniqueArgs} args - Arguments to find a MediaCategory
     * @example
     * // Get one MediaCategory
     * const mediaCategory = await prisma.mediaCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaCategoryFindUniqueArgs>(args: SelectSubset<T, MediaCategoryFindUniqueArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaCategoryFindUniqueOrThrowArgs} args - Arguments to find a MediaCategory
     * @example
     * // Get one MediaCategory
     * const mediaCategory = await prisma.mediaCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCategoryFindFirstArgs} args - Arguments to find a MediaCategory
     * @example
     * // Get one MediaCategory
     * const mediaCategory = await prisma.mediaCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaCategoryFindFirstArgs>(args?: SelectSubset<T, MediaCategoryFindFirstArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCategoryFindFirstOrThrowArgs} args - Arguments to find a MediaCategory
     * @example
     * // Get one MediaCategory
     * const mediaCategory = await prisma.mediaCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaCategories
     * const mediaCategories = await prisma.mediaCategory.findMany()
     * 
     * // Get first 10 MediaCategories
     * const mediaCategories = await prisma.mediaCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaCategoryWithIdOnly = await prisma.mediaCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaCategoryFindManyArgs>(args?: SelectSubset<T, MediaCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaCategory.
     * @param {MediaCategoryCreateArgs} args - Arguments to create a MediaCategory.
     * @example
     * // Create one MediaCategory
     * const MediaCategory = await prisma.mediaCategory.create({
     *   data: {
     *     // ... data to create a MediaCategory
     *   }
     * })
     * 
     */
    create<T extends MediaCategoryCreateArgs>(args: SelectSubset<T, MediaCategoryCreateArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaCategories.
     * @param {MediaCategoryCreateManyArgs} args - Arguments to create many MediaCategories.
     * @example
     * // Create many MediaCategories
     * const mediaCategory = await prisma.mediaCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCategoryCreateManyArgs>(args?: SelectSubset<T, MediaCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaCategories and returns the data saved in the database.
     * @param {MediaCategoryCreateManyAndReturnArgs} args - Arguments to create many MediaCategories.
     * @example
     * // Create many MediaCategories
     * const mediaCategory = await prisma.mediaCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaCategories and only return the `id`
     * const mediaCategoryWithIdOnly = await prisma.mediaCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaCategory.
     * @param {MediaCategoryDeleteArgs} args - Arguments to delete one MediaCategory.
     * @example
     * // Delete one MediaCategory
     * const MediaCategory = await prisma.mediaCategory.delete({
     *   where: {
     *     // ... filter to delete one MediaCategory
     *   }
     * })
     * 
     */
    delete<T extends MediaCategoryDeleteArgs>(args: SelectSubset<T, MediaCategoryDeleteArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaCategory.
     * @param {MediaCategoryUpdateArgs} args - Arguments to update one MediaCategory.
     * @example
     * // Update one MediaCategory
     * const mediaCategory = await prisma.mediaCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaCategoryUpdateArgs>(args: SelectSubset<T, MediaCategoryUpdateArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaCategories.
     * @param {MediaCategoryDeleteManyArgs} args - Arguments to filter MediaCategories to delete.
     * @example
     * // Delete a few MediaCategories
     * const { count } = await prisma.mediaCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaCategoryDeleteManyArgs>(args?: SelectSubset<T, MediaCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaCategories
     * const mediaCategory = await prisma.mediaCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaCategoryUpdateManyArgs>(args: SelectSubset<T, MediaCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaCategory.
     * @param {MediaCategoryUpsertArgs} args - Arguments to update or create a MediaCategory.
     * @example
     * // Update or create a MediaCategory
     * const mediaCategory = await prisma.mediaCategory.upsert({
     *   create: {
     *     // ... data to create a MediaCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaCategory we want to update
     *   }
     * })
     */
    upsert<T extends MediaCategoryUpsertArgs>(args: SelectSubset<T, MediaCategoryUpsertArgs<ExtArgs>>): Prisma__MediaCategoryClient<$Result.GetResult<Prisma.$MediaCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCategoryCountArgs} args - Arguments to filter MediaCategories to count.
     * @example
     * // Count the number of MediaCategories
     * const count = await prisma.mediaCategory.count({
     *   where: {
     *     // ... the filter for the MediaCategories we want to count
     *   }
     * })
    **/
    count<T extends MediaCategoryCountArgs>(
      args?: Subset<T, MediaCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaCategoryAggregateArgs>(args: Subset<T, MediaCategoryAggregateArgs>): Prisma.PrismaPromise<GetMediaCategoryAggregateType<T>>

    /**
     * Group by MediaCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaCategoryGroupByArgs['orderBy'] }
        : { orderBy?: MediaCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaCategory model
   */
  readonly fields: MediaCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends MediaCategory$mediaArgs<ExtArgs> = {}>(args?: Subset<T, MediaCategory$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaCategory model
   */ 
  interface MediaCategoryFieldRefs {
    readonly id: FieldRef<"MediaCategory", 'String'>
    readonly name: FieldRef<"MediaCategory", 'String'>
    readonly description: FieldRef<"MediaCategory", 'String'>
    readonly allowedTypes: FieldRef<"MediaCategory", 'Json'>
    readonly maxFileSize: FieldRef<"MediaCategory", 'BigInt'>
    readonly compressionEnabled: FieldRef<"MediaCategory", 'Boolean'>
    readonly previewEnabled: FieldRef<"MediaCategory", 'Boolean'>
    readonly createdAt: FieldRef<"MediaCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaCategory findUnique
   */
  export type MediaCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MediaCategory to fetch.
     */
    where: MediaCategoryWhereUniqueInput
  }

  /**
   * MediaCategory findUniqueOrThrow
   */
  export type MediaCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MediaCategory to fetch.
     */
    where: MediaCategoryWhereUniqueInput
  }

  /**
   * MediaCategory findFirst
   */
  export type MediaCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MediaCategory to fetch.
     */
    where?: MediaCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaCategories to fetch.
     */
    orderBy?: MediaCategoryOrderByWithRelationInput | MediaCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaCategories.
     */
    cursor?: MediaCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaCategories.
     */
    distinct?: MediaCategoryScalarFieldEnum | MediaCategoryScalarFieldEnum[]
  }

  /**
   * MediaCategory findFirstOrThrow
   */
  export type MediaCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MediaCategory to fetch.
     */
    where?: MediaCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaCategories to fetch.
     */
    orderBy?: MediaCategoryOrderByWithRelationInput | MediaCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaCategories.
     */
    cursor?: MediaCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaCategories.
     */
    distinct?: MediaCategoryScalarFieldEnum | MediaCategoryScalarFieldEnum[]
  }

  /**
   * MediaCategory findMany
   */
  export type MediaCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * Filter, which MediaCategories to fetch.
     */
    where?: MediaCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaCategories to fetch.
     */
    orderBy?: MediaCategoryOrderByWithRelationInput | MediaCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaCategories.
     */
    cursor?: MediaCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaCategories.
     */
    skip?: number
    distinct?: MediaCategoryScalarFieldEnum | MediaCategoryScalarFieldEnum[]
  }

  /**
   * MediaCategory create
   */
  export type MediaCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaCategory.
     */
    data: XOR<MediaCategoryCreateInput, MediaCategoryUncheckedCreateInput>
  }

  /**
   * MediaCategory createMany
   */
  export type MediaCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaCategories.
     */
    data: MediaCategoryCreateManyInput | MediaCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaCategory createManyAndReturn
   */
  export type MediaCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaCategories.
     */
    data: MediaCategoryCreateManyInput | MediaCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaCategory update
   */
  export type MediaCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaCategory.
     */
    data: XOR<MediaCategoryUpdateInput, MediaCategoryUncheckedUpdateInput>
    /**
     * Choose, which MediaCategory to update.
     */
    where: MediaCategoryWhereUniqueInput
  }

  /**
   * MediaCategory updateMany
   */
  export type MediaCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaCategories.
     */
    data: XOR<MediaCategoryUpdateManyMutationInput, MediaCategoryUncheckedUpdateManyInput>
    /**
     * Filter which MediaCategories to update
     */
    where?: MediaCategoryWhereInput
  }

  /**
   * MediaCategory upsert
   */
  export type MediaCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaCategory to update in case it exists.
     */
    where: MediaCategoryWhereUniqueInput
    /**
     * In case the MediaCategory found by the `where` argument doesn't exist, create a new MediaCategory with this data.
     */
    create: XOR<MediaCategoryCreateInput, MediaCategoryUncheckedCreateInput>
    /**
     * In case the MediaCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaCategoryUpdateInput, MediaCategoryUncheckedUpdateInput>
  }

  /**
   * MediaCategory delete
   */
  export type MediaCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
    /**
     * Filter which MediaCategory to delete.
     */
    where: MediaCategoryWhereUniqueInput
  }

  /**
   * MediaCategory deleteMany
   */
  export type MediaCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaCategories to delete
     */
    where?: MediaCategoryWhereInput
  }

  /**
   * MediaCategory.media
   */
  export type MediaCategory$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * MediaCategory without action
   */
  export type MediaCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCategory
     */
    select?: MediaCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaCategoryInclude<ExtArgs> | null
  }


  /**
   * Model MediaAccessLog
   */

  export type AggregateMediaAccessLog = {
    _count: MediaAccessLogCountAggregateOutputType | null
    _min: MediaAccessLogMinAggregateOutputType | null
    _max: MediaAccessLogMaxAggregateOutputType | null
  }

  export type MediaAccessLogMinAggregateOutputType = {
    id: string | null
    mediaId: string | null
    userId: string | null
    actionType: string | null
    clientIp: string | null
    userAgent: string | null
    accessedAt: Date | null
  }

  export type MediaAccessLogMaxAggregateOutputType = {
    id: string | null
    mediaId: string | null
    userId: string | null
    actionType: string | null
    clientIp: string | null
    userAgent: string | null
    accessedAt: Date | null
  }

  export type MediaAccessLogCountAggregateOutputType = {
    id: number
    mediaId: number
    userId: number
    actionType: number
    clientIp: number
    userAgent: number
    requestMetadata: number
    accessedAt: number
    _all: number
  }


  export type MediaAccessLogMinAggregateInputType = {
    id?: true
    mediaId?: true
    userId?: true
    actionType?: true
    clientIp?: true
    userAgent?: true
    accessedAt?: true
  }

  export type MediaAccessLogMaxAggregateInputType = {
    id?: true
    mediaId?: true
    userId?: true
    actionType?: true
    clientIp?: true
    userAgent?: true
    accessedAt?: true
  }

  export type MediaAccessLogCountAggregateInputType = {
    id?: true
    mediaId?: true
    userId?: true
    actionType?: true
    clientIp?: true
    userAgent?: true
    requestMetadata?: true
    accessedAt?: true
    _all?: true
  }

  export type MediaAccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAccessLog to aggregate.
     */
    where?: MediaAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAccessLogs to fetch.
     */
    orderBy?: MediaAccessLogOrderByWithRelationInput | MediaAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaAccessLogs
    **/
    _count?: true | MediaAccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaAccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaAccessLogMaxAggregateInputType
  }

  export type GetMediaAccessLogAggregateType<T extends MediaAccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaAccessLog[P]>
      : GetScalarType<T[P], AggregateMediaAccessLog[P]>
  }




  export type MediaAccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAccessLogWhereInput
    orderBy?: MediaAccessLogOrderByWithAggregationInput | MediaAccessLogOrderByWithAggregationInput[]
    by: MediaAccessLogScalarFieldEnum[] | MediaAccessLogScalarFieldEnum
    having?: MediaAccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaAccessLogCountAggregateInputType | true
    _min?: MediaAccessLogMinAggregateInputType
    _max?: MediaAccessLogMaxAggregateInputType
  }

  export type MediaAccessLogGroupByOutputType = {
    id: string
    mediaId: string
    userId: string
    actionType: string
    clientIp: string | null
    userAgent: string | null
    requestMetadata: JsonValue
    accessedAt: Date
    _count: MediaAccessLogCountAggregateOutputType | null
    _min: MediaAccessLogMinAggregateOutputType | null
    _max: MediaAccessLogMaxAggregateOutputType | null
  }

  type GetMediaAccessLogGroupByPayload<T extends MediaAccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaAccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaAccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaAccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], MediaAccessLogGroupByOutputType[P]>
        }
      >
    >


  export type MediaAccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaId?: boolean
    userId?: boolean
    actionType?: boolean
    clientIp?: boolean
    userAgent?: boolean
    requestMetadata?: boolean
    accessedAt?: boolean
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAccessLog"]>

  export type MediaAccessLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaId?: boolean
    userId?: boolean
    actionType?: boolean
    clientIp?: boolean
    userAgent?: boolean
    requestMetadata?: boolean
    accessedAt?: boolean
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAccessLog"]>

  export type MediaAccessLogSelectScalar = {
    id?: boolean
    mediaId?: boolean
    userId?: boolean
    actionType?: boolean
    clientIp?: boolean
    userAgent?: boolean
    requestMetadata?: boolean
    accessedAt?: boolean
  }

  export type MediaAccessLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type MediaAccessLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $MediaAccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaAccessLog"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mediaId: string
      userId: string
      actionType: string
      clientIp: string | null
      userAgent: string | null
      requestMetadata: Prisma.JsonValue
      accessedAt: Date
    }, ExtArgs["result"]["mediaAccessLog"]>
    composites: {}
  }

  type MediaAccessLogGetPayload<S extends boolean | null | undefined | MediaAccessLogDefaultArgs> = $Result.GetResult<Prisma.$MediaAccessLogPayload, S>

  type MediaAccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaAccessLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaAccessLogCountAggregateInputType | true
    }

  export interface MediaAccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaAccessLog'], meta: { name: 'MediaAccessLog' } }
    /**
     * Find zero or one MediaAccessLog that matches the filter.
     * @param {MediaAccessLogFindUniqueArgs} args - Arguments to find a MediaAccessLog
     * @example
     * // Get one MediaAccessLog
     * const mediaAccessLog = await prisma.mediaAccessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaAccessLogFindUniqueArgs>(args: SelectSubset<T, MediaAccessLogFindUniqueArgs<ExtArgs>>): Prisma__MediaAccessLogClient<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaAccessLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaAccessLogFindUniqueOrThrowArgs} args - Arguments to find a MediaAccessLog
     * @example
     * // Get one MediaAccessLog
     * const mediaAccessLog = await prisma.mediaAccessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaAccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaAccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaAccessLogClient<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaAccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAccessLogFindFirstArgs} args - Arguments to find a MediaAccessLog
     * @example
     * // Get one MediaAccessLog
     * const mediaAccessLog = await prisma.mediaAccessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaAccessLogFindFirstArgs>(args?: SelectSubset<T, MediaAccessLogFindFirstArgs<ExtArgs>>): Prisma__MediaAccessLogClient<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaAccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAccessLogFindFirstOrThrowArgs} args - Arguments to find a MediaAccessLog
     * @example
     * // Get one MediaAccessLog
     * const mediaAccessLog = await prisma.mediaAccessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaAccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaAccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaAccessLogClient<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaAccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaAccessLogs
     * const mediaAccessLogs = await prisma.mediaAccessLog.findMany()
     * 
     * // Get first 10 MediaAccessLogs
     * const mediaAccessLogs = await prisma.mediaAccessLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaAccessLogWithIdOnly = await prisma.mediaAccessLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaAccessLogFindManyArgs>(args?: SelectSubset<T, MediaAccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaAccessLog.
     * @param {MediaAccessLogCreateArgs} args - Arguments to create a MediaAccessLog.
     * @example
     * // Create one MediaAccessLog
     * const MediaAccessLog = await prisma.mediaAccessLog.create({
     *   data: {
     *     // ... data to create a MediaAccessLog
     *   }
     * })
     * 
     */
    create<T extends MediaAccessLogCreateArgs>(args: SelectSubset<T, MediaAccessLogCreateArgs<ExtArgs>>): Prisma__MediaAccessLogClient<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaAccessLogs.
     * @param {MediaAccessLogCreateManyArgs} args - Arguments to create many MediaAccessLogs.
     * @example
     * // Create many MediaAccessLogs
     * const mediaAccessLog = await prisma.mediaAccessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaAccessLogCreateManyArgs>(args?: SelectSubset<T, MediaAccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaAccessLogs and returns the data saved in the database.
     * @param {MediaAccessLogCreateManyAndReturnArgs} args - Arguments to create many MediaAccessLogs.
     * @example
     * // Create many MediaAccessLogs
     * const mediaAccessLog = await prisma.mediaAccessLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaAccessLogs and only return the `id`
     * const mediaAccessLogWithIdOnly = await prisma.mediaAccessLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaAccessLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaAccessLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaAccessLog.
     * @param {MediaAccessLogDeleteArgs} args - Arguments to delete one MediaAccessLog.
     * @example
     * // Delete one MediaAccessLog
     * const MediaAccessLog = await prisma.mediaAccessLog.delete({
     *   where: {
     *     // ... filter to delete one MediaAccessLog
     *   }
     * })
     * 
     */
    delete<T extends MediaAccessLogDeleteArgs>(args: SelectSubset<T, MediaAccessLogDeleteArgs<ExtArgs>>): Prisma__MediaAccessLogClient<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaAccessLog.
     * @param {MediaAccessLogUpdateArgs} args - Arguments to update one MediaAccessLog.
     * @example
     * // Update one MediaAccessLog
     * const mediaAccessLog = await prisma.mediaAccessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaAccessLogUpdateArgs>(args: SelectSubset<T, MediaAccessLogUpdateArgs<ExtArgs>>): Prisma__MediaAccessLogClient<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaAccessLogs.
     * @param {MediaAccessLogDeleteManyArgs} args - Arguments to filter MediaAccessLogs to delete.
     * @example
     * // Delete a few MediaAccessLogs
     * const { count } = await prisma.mediaAccessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaAccessLogDeleteManyArgs>(args?: SelectSubset<T, MediaAccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaAccessLogs
     * const mediaAccessLog = await prisma.mediaAccessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaAccessLogUpdateManyArgs>(args: SelectSubset<T, MediaAccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaAccessLog.
     * @param {MediaAccessLogUpsertArgs} args - Arguments to update or create a MediaAccessLog.
     * @example
     * // Update or create a MediaAccessLog
     * const mediaAccessLog = await prisma.mediaAccessLog.upsert({
     *   create: {
     *     // ... data to create a MediaAccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaAccessLog we want to update
     *   }
     * })
     */
    upsert<T extends MediaAccessLogUpsertArgs>(args: SelectSubset<T, MediaAccessLogUpsertArgs<ExtArgs>>): Prisma__MediaAccessLogClient<$Result.GetResult<Prisma.$MediaAccessLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAccessLogCountArgs} args - Arguments to filter MediaAccessLogs to count.
     * @example
     * // Count the number of MediaAccessLogs
     * const count = await prisma.mediaAccessLog.count({
     *   where: {
     *     // ... the filter for the MediaAccessLogs we want to count
     *   }
     * })
    **/
    count<T extends MediaAccessLogCountArgs>(
      args?: Subset<T, MediaAccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaAccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAccessLogAggregateArgs>(args: Subset<T, MediaAccessLogAggregateArgs>): Prisma.PrismaPromise<GetMediaAccessLogAggregateType<T>>

    /**
     * Group by MediaAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaAccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaAccessLogGroupByArgs['orderBy'] }
        : { orderBy?: MediaAccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaAccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaAccessLog model
   */
  readonly fields: MediaAccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaAccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaAccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaAccessLog model
   */ 
  interface MediaAccessLogFieldRefs {
    readonly id: FieldRef<"MediaAccessLog", 'String'>
    readonly mediaId: FieldRef<"MediaAccessLog", 'String'>
    readonly userId: FieldRef<"MediaAccessLog", 'String'>
    readonly actionType: FieldRef<"MediaAccessLog", 'String'>
    readonly clientIp: FieldRef<"MediaAccessLog", 'String'>
    readonly userAgent: FieldRef<"MediaAccessLog", 'String'>
    readonly requestMetadata: FieldRef<"MediaAccessLog", 'Json'>
    readonly accessedAt: FieldRef<"MediaAccessLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaAccessLog findUnique
   */
  export type MediaAccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MediaAccessLog to fetch.
     */
    where: MediaAccessLogWhereUniqueInput
  }

  /**
   * MediaAccessLog findUniqueOrThrow
   */
  export type MediaAccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MediaAccessLog to fetch.
     */
    where: MediaAccessLogWhereUniqueInput
  }

  /**
   * MediaAccessLog findFirst
   */
  export type MediaAccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MediaAccessLog to fetch.
     */
    where?: MediaAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAccessLogs to fetch.
     */
    orderBy?: MediaAccessLogOrderByWithRelationInput | MediaAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAccessLogs.
     */
    cursor?: MediaAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAccessLogs.
     */
    distinct?: MediaAccessLogScalarFieldEnum | MediaAccessLogScalarFieldEnum[]
  }

  /**
   * MediaAccessLog findFirstOrThrow
   */
  export type MediaAccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MediaAccessLog to fetch.
     */
    where?: MediaAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAccessLogs to fetch.
     */
    orderBy?: MediaAccessLogOrderByWithRelationInput | MediaAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAccessLogs.
     */
    cursor?: MediaAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAccessLogs.
     */
    distinct?: MediaAccessLogScalarFieldEnum | MediaAccessLogScalarFieldEnum[]
  }

  /**
   * MediaAccessLog findMany
   */
  export type MediaAccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MediaAccessLogs to fetch.
     */
    where?: MediaAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAccessLogs to fetch.
     */
    orderBy?: MediaAccessLogOrderByWithRelationInput | MediaAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaAccessLogs.
     */
    cursor?: MediaAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAccessLogs.
     */
    skip?: number
    distinct?: MediaAccessLogScalarFieldEnum | MediaAccessLogScalarFieldEnum[]
  }

  /**
   * MediaAccessLog create
   */
  export type MediaAccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaAccessLog.
     */
    data: XOR<MediaAccessLogCreateInput, MediaAccessLogUncheckedCreateInput>
  }

  /**
   * MediaAccessLog createMany
   */
  export type MediaAccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaAccessLogs.
     */
    data: MediaAccessLogCreateManyInput | MediaAccessLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaAccessLog createManyAndReturn
   */
  export type MediaAccessLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaAccessLogs.
     */
    data: MediaAccessLogCreateManyInput | MediaAccessLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaAccessLog update
   */
  export type MediaAccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaAccessLog.
     */
    data: XOR<MediaAccessLogUpdateInput, MediaAccessLogUncheckedUpdateInput>
    /**
     * Choose, which MediaAccessLog to update.
     */
    where: MediaAccessLogWhereUniqueInput
  }

  /**
   * MediaAccessLog updateMany
   */
  export type MediaAccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaAccessLogs.
     */
    data: XOR<MediaAccessLogUpdateManyMutationInput, MediaAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which MediaAccessLogs to update
     */
    where?: MediaAccessLogWhereInput
  }

  /**
   * MediaAccessLog upsert
   */
  export type MediaAccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaAccessLog to update in case it exists.
     */
    where: MediaAccessLogWhereUniqueInput
    /**
     * In case the MediaAccessLog found by the `where` argument doesn't exist, create a new MediaAccessLog with this data.
     */
    create: XOR<MediaAccessLogCreateInput, MediaAccessLogUncheckedCreateInput>
    /**
     * In case the MediaAccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaAccessLogUpdateInput, MediaAccessLogUncheckedUpdateInput>
  }

  /**
   * MediaAccessLog delete
   */
  export type MediaAccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
    /**
     * Filter which MediaAccessLog to delete.
     */
    where: MediaAccessLogWhereUniqueInput
  }

  /**
   * MediaAccessLog deleteMany
   */
  export type MediaAccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAccessLogs to delete
     */
    where?: MediaAccessLogWhereInput
  }

  /**
   * MediaAccessLog without action
   */
  export type MediaAccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAccessLog
     */
    select?: MediaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAccessLogInclude<ExtArgs> | null
  }


  /**
   * Model MediaShare
   */

  export type AggregateMediaShare = {
    _count: MediaShareCountAggregateOutputType | null
    _min: MediaShareMinAggregateOutputType | null
    _max: MediaShareMaxAggregateOutputType | null
  }

  export type MediaShareMinAggregateOutputType = {
    id: string | null
    mediaId: string | null
    sharedBy: string | null
    sharedWith: string | null
    permissionLevel: string | null
    sharedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type MediaShareMaxAggregateOutputType = {
    id: string | null
    mediaId: string | null
    sharedBy: string | null
    sharedWith: string | null
    permissionLevel: string | null
    sharedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type MediaShareCountAggregateOutputType = {
    id: number
    mediaId: number
    sharedBy: number
    sharedWith: number
    permissionLevel: number
    sharedAt: number
    expiresAt: number
    isActive: number
    _all: number
  }


  export type MediaShareMinAggregateInputType = {
    id?: true
    mediaId?: true
    sharedBy?: true
    sharedWith?: true
    permissionLevel?: true
    sharedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type MediaShareMaxAggregateInputType = {
    id?: true
    mediaId?: true
    sharedBy?: true
    sharedWith?: true
    permissionLevel?: true
    sharedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type MediaShareCountAggregateInputType = {
    id?: true
    mediaId?: true
    sharedBy?: true
    sharedWith?: true
    permissionLevel?: true
    sharedAt?: true
    expiresAt?: true
    isActive?: true
    _all?: true
  }

  export type MediaShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaShare to aggregate.
     */
    where?: MediaShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaShares to fetch.
     */
    orderBy?: MediaShareOrderByWithRelationInput | MediaShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaShares
    **/
    _count?: true | MediaShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaShareMaxAggregateInputType
  }

  export type GetMediaShareAggregateType<T extends MediaShareAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaShare[P]>
      : GetScalarType<T[P], AggregateMediaShare[P]>
  }




  export type MediaShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaShareWhereInput
    orderBy?: MediaShareOrderByWithAggregationInput | MediaShareOrderByWithAggregationInput[]
    by: MediaShareScalarFieldEnum[] | MediaShareScalarFieldEnum
    having?: MediaShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaShareCountAggregateInputType | true
    _min?: MediaShareMinAggregateInputType
    _max?: MediaShareMaxAggregateInputType
  }

  export type MediaShareGroupByOutputType = {
    id: string
    mediaId: string
    sharedBy: string
    sharedWith: string
    permissionLevel: string
    sharedAt: Date
    expiresAt: Date | null
    isActive: boolean
    _count: MediaShareCountAggregateOutputType | null
    _min: MediaShareMinAggregateOutputType | null
    _max: MediaShareMaxAggregateOutputType | null
  }

  type GetMediaShareGroupByPayload<T extends MediaShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaShareGroupByOutputType[P]>
            : GetScalarType<T[P], MediaShareGroupByOutputType[P]>
        }
      >
    >


  export type MediaShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permissionLevel?: boolean
    sharedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaShare"]>

  export type MediaShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permissionLevel?: boolean
    sharedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaShare"]>

  export type MediaShareSelectScalar = {
    id?: boolean
    mediaId?: boolean
    sharedBy?: boolean
    sharedWith?: boolean
    permissionLevel?: boolean
    sharedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
  }

  export type MediaShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type MediaShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $MediaSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaShare"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mediaId: string
      sharedBy: string
      sharedWith: string
      permissionLevel: string
      sharedAt: Date
      expiresAt: Date | null
      isActive: boolean
    }, ExtArgs["result"]["mediaShare"]>
    composites: {}
  }

  type MediaShareGetPayload<S extends boolean | null | undefined | MediaShareDefaultArgs> = $Result.GetResult<Prisma.$MediaSharePayload, S>

  type MediaShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaShareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaShareCountAggregateInputType | true
    }

  export interface MediaShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaShare'], meta: { name: 'MediaShare' } }
    /**
     * Find zero or one MediaShare that matches the filter.
     * @param {MediaShareFindUniqueArgs} args - Arguments to find a MediaShare
     * @example
     * // Get one MediaShare
     * const mediaShare = await prisma.mediaShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaShareFindUniqueArgs>(args: SelectSubset<T, MediaShareFindUniqueArgs<ExtArgs>>): Prisma__MediaShareClient<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaShare that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaShareFindUniqueOrThrowArgs} args - Arguments to find a MediaShare
     * @example
     * // Get one MediaShare
     * const mediaShare = await prisma.mediaShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaShareFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaShareClient<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaShareFindFirstArgs} args - Arguments to find a MediaShare
     * @example
     * // Get one MediaShare
     * const mediaShare = await prisma.mediaShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaShareFindFirstArgs>(args?: SelectSubset<T, MediaShareFindFirstArgs<ExtArgs>>): Prisma__MediaShareClient<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaShareFindFirstOrThrowArgs} args - Arguments to find a MediaShare
     * @example
     * // Get one MediaShare
     * const mediaShare = await prisma.mediaShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaShareFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaShareClient<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaShares
     * const mediaShares = await prisma.mediaShare.findMany()
     * 
     * // Get first 10 MediaShares
     * const mediaShares = await prisma.mediaShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaShareWithIdOnly = await prisma.mediaShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaShareFindManyArgs>(args?: SelectSubset<T, MediaShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaShare.
     * @param {MediaShareCreateArgs} args - Arguments to create a MediaShare.
     * @example
     * // Create one MediaShare
     * const MediaShare = await prisma.mediaShare.create({
     *   data: {
     *     // ... data to create a MediaShare
     *   }
     * })
     * 
     */
    create<T extends MediaShareCreateArgs>(args: SelectSubset<T, MediaShareCreateArgs<ExtArgs>>): Prisma__MediaShareClient<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaShares.
     * @param {MediaShareCreateManyArgs} args - Arguments to create many MediaShares.
     * @example
     * // Create many MediaShares
     * const mediaShare = await prisma.mediaShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaShareCreateManyArgs>(args?: SelectSubset<T, MediaShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaShares and returns the data saved in the database.
     * @param {MediaShareCreateManyAndReturnArgs} args - Arguments to create many MediaShares.
     * @example
     * // Create many MediaShares
     * const mediaShare = await prisma.mediaShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaShares and only return the `id`
     * const mediaShareWithIdOnly = await prisma.mediaShare.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaShareCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaShare.
     * @param {MediaShareDeleteArgs} args - Arguments to delete one MediaShare.
     * @example
     * // Delete one MediaShare
     * const MediaShare = await prisma.mediaShare.delete({
     *   where: {
     *     // ... filter to delete one MediaShare
     *   }
     * })
     * 
     */
    delete<T extends MediaShareDeleteArgs>(args: SelectSubset<T, MediaShareDeleteArgs<ExtArgs>>): Prisma__MediaShareClient<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaShare.
     * @param {MediaShareUpdateArgs} args - Arguments to update one MediaShare.
     * @example
     * // Update one MediaShare
     * const mediaShare = await prisma.mediaShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaShareUpdateArgs>(args: SelectSubset<T, MediaShareUpdateArgs<ExtArgs>>): Prisma__MediaShareClient<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaShares.
     * @param {MediaShareDeleteManyArgs} args - Arguments to filter MediaShares to delete.
     * @example
     * // Delete a few MediaShares
     * const { count } = await prisma.mediaShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaShareDeleteManyArgs>(args?: SelectSubset<T, MediaShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaShares
     * const mediaShare = await prisma.mediaShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaShareUpdateManyArgs>(args: SelectSubset<T, MediaShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaShare.
     * @param {MediaShareUpsertArgs} args - Arguments to update or create a MediaShare.
     * @example
     * // Update or create a MediaShare
     * const mediaShare = await prisma.mediaShare.upsert({
     *   create: {
     *     // ... data to create a MediaShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaShare we want to update
     *   }
     * })
     */
    upsert<T extends MediaShareUpsertArgs>(args: SelectSubset<T, MediaShareUpsertArgs<ExtArgs>>): Prisma__MediaShareClient<$Result.GetResult<Prisma.$MediaSharePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaShareCountArgs} args - Arguments to filter MediaShares to count.
     * @example
     * // Count the number of MediaShares
     * const count = await prisma.mediaShare.count({
     *   where: {
     *     // ... the filter for the MediaShares we want to count
     *   }
     * })
    **/
    count<T extends MediaShareCountArgs>(
      args?: Subset<T, MediaShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaShareAggregateArgs>(args: Subset<T, MediaShareAggregateArgs>): Prisma.PrismaPromise<GetMediaShareAggregateType<T>>

    /**
     * Group by MediaShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaShareGroupByArgs['orderBy'] }
        : { orderBy?: MediaShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaShare model
   */
  readonly fields: MediaShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaShare model
   */ 
  interface MediaShareFieldRefs {
    readonly id: FieldRef<"MediaShare", 'String'>
    readonly mediaId: FieldRef<"MediaShare", 'String'>
    readonly sharedBy: FieldRef<"MediaShare", 'String'>
    readonly sharedWith: FieldRef<"MediaShare", 'String'>
    readonly permissionLevel: FieldRef<"MediaShare", 'String'>
    readonly sharedAt: FieldRef<"MediaShare", 'DateTime'>
    readonly expiresAt: FieldRef<"MediaShare", 'DateTime'>
    readonly isActive: FieldRef<"MediaShare", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MediaShare findUnique
   */
  export type MediaShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * Filter, which MediaShare to fetch.
     */
    where: MediaShareWhereUniqueInput
  }

  /**
   * MediaShare findUniqueOrThrow
   */
  export type MediaShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * Filter, which MediaShare to fetch.
     */
    where: MediaShareWhereUniqueInput
  }

  /**
   * MediaShare findFirst
   */
  export type MediaShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * Filter, which MediaShare to fetch.
     */
    where?: MediaShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaShares to fetch.
     */
    orderBy?: MediaShareOrderByWithRelationInput | MediaShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaShares.
     */
    cursor?: MediaShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaShares.
     */
    distinct?: MediaShareScalarFieldEnum | MediaShareScalarFieldEnum[]
  }

  /**
   * MediaShare findFirstOrThrow
   */
  export type MediaShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * Filter, which MediaShare to fetch.
     */
    where?: MediaShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaShares to fetch.
     */
    orderBy?: MediaShareOrderByWithRelationInput | MediaShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaShares.
     */
    cursor?: MediaShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaShares.
     */
    distinct?: MediaShareScalarFieldEnum | MediaShareScalarFieldEnum[]
  }

  /**
   * MediaShare findMany
   */
  export type MediaShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * Filter, which MediaShares to fetch.
     */
    where?: MediaShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaShares to fetch.
     */
    orderBy?: MediaShareOrderByWithRelationInput | MediaShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaShares.
     */
    cursor?: MediaShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaShares.
     */
    skip?: number
    distinct?: MediaShareScalarFieldEnum | MediaShareScalarFieldEnum[]
  }

  /**
   * MediaShare create
   */
  export type MediaShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaShare.
     */
    data: XOR<MediaShareCreateInput, MediaShareUncheckedCreateInput>
  }

  /**
   * MediaShare createMany
   */
  export type MediaShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaShares.
     */
    data: MediaShareCreateManyInput | MediaShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaShare createManyAndReturn
   */
  export type MediaShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaShares.
     */
    data: MediaShareCreateManyInput | MediaShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaShare update
   */
  export type MediaShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaShare.
     */
    data: XOR<MediaShareUpdateInput, MediaShareUncheckedUpdateInput>
    /**
     * Choose, which MediaShare to update.
     */
    where: MediaShareWhereUniqueInput
  }

  /**
   * MediaShare updateMany
   */
  export type MediaShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaShares.
     */
    data: XOR<MediaShareUpdateManyMutationInput, MediaShareUncheckedUpdateManyInput>
    /**
     * Filter which MediaShares to update
     */
    where?: MediaShareWhereInput
  }

  /**
   * MediaShare upsert
   */
  export type MediaShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaShare to update in case it exists.
     */
    where: MediaShareWhereUniqueInput
    /**
     * In case the MediaShare found by the `where` argument doesn't exist, create a new MediaShare with this data.
     */
    create: XOR<MediaShareCreateInput, MediaShareUncheckedCreateInput>
    /**
     * In case the MediaShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaShareUpdateInput, MediaShareUncheckedUpdateInput>
  }

  /**
   * MediaShare delete
   */
  export type MediaShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
    /**
     * Filter which MediaShare to delete.
     */
    where: MediaShareWhereUniqueInput
  }

  /**
   * MediaShare deleteMany
   */
  export type MediaShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaShares to delete
     */
    where?: MediaShareWhereInput
  }

  /**
   * MediaShare without action
   */
  export type MediaShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaShare
     */
    select?: MediaShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaShareInclude<ExtArgs> | null
  }


  /**
   * Model ModerationHash
   */

  export type AggregateModerationHash = {
    _count: ModerationHashCountAggregateOutputType | null
    _min: ModerationHashMinAggregateOutputType | null
    _max: ModerationHashMaxAggregateOutputType | null
  }

  export type ModerationHashMinAggregateOutputType = {
    id: string | null
    hashValue: string | null
    hashType: string | null
    status: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModerationHashMaxAggregateOutputType = {
    id: string | null
    hashValue: string | null
    hashType: string | null
    status: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModerationHashCountAggregateOutputType = {
    id: number
    hashValue: number
    hashType: number
    status: number
    reason: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModerationHashMinAggregateInputType = {
    id?: true
    hashValue?: true
    hashType?: true
    status?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModerationHashMaxAggregateInputType = {
    id?: true
    hashValue?: true
    hashType?: true
    status?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModerationHashCountAggregateInputType = {
    id?: true
    hashValue?: true
    hashType?: true
    status?: true
    reason?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModerationHashAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationHash to aggregate.
     */
    where?: ModerationHashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationHashes to fetch.
     */
    orderBy?: ModerationHashOrderByWithRelationInput | ModerationHashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationHashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationHashes
    **/
    _count?: true | ModerationHashCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationHashMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationHashMaxAggregateInputType
  }

  export type GetModerationHashAggregateType<T extends ModerationHashAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationHash]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationHash[P]>
      : GetScalarType<T[P], AggregateModerationHash[P]>
  }




  export type ModerationHashGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationHashWhereInput
    orderBy?: ModerationHashOrderByWithAggregationInput | ModerationHashOrderByWithAggregationInput[]
    by: ModerationHashScalarFieldEnum[] | ModerationHashScalarFieldEnum
    having?: ModerationHashScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationHashCountAggregateInputType | true
    _min?: ModerationHashMinAggregateInputType
    _max?: ModerationHashMaxAggregateInputType
  }

  export type ModerationHashGroupByOutputType = {
    id: string
    hashValue: string
    hashType: string
    status: string
    reason: string | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ModerationHashCountAggregateOutputType | null
    _min: ModerationHashMinAggregateOutputType | null
    _max: ModerationHashMaxAggregateOutputType | null
  }

  type GetModerationHashGroupByPayload<T extends ModerationHashGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationHashGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationHashGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationHashGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationHashGroupByOutputType[P]>
        }
      >
    >


  export type ModerationHashSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hashValue?: boolean
    hashType?: boolean
    status?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["moderationHash"]>

  export type ModerationHashSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hashValue?: boolean
    hashType?: boolean
    status?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["moderationHash"]>

  export type ModerationHashSelectScalar = {
    id?: boolean
    hashValue?: boolean
    hashType?: boolean
    status?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ModerationHashPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationHash"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hashValue: string
      hashType: string
      status: string
      reason: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moderationHash"]>
    composites: {}
  }

  type ModerationHashGetPayload<S extends boolean | null | undefined | ModerationHashDefaultArgs> = $Result.GetResult<Prisma.$ModerationHashPayload, S>

  type ModerationHashCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModerationHashFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModerationHashCountAggregateInputType | true
    }

  export interface ModerationHashDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationHash'], meta: { name: 'ModerationHash' } }
    /**
     * Find zero or one ModerationHash that matches the filter.
     * @param {ModerationHashFindUniqueArgs} args - Arguments to find a ModerationHash
     * @example
     * // Get one ModerationHash
     * const moderationHash = await prisma.moderationHash.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModerationHashFindUniqueArgs>(args: SelectSubset<T, ModerationHashFindUniqueArgs<ExtArgs>>): Prisma__ModerationHashClient<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModerationHash that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModerationHashFindUniqueOrThrowArgs} args - Arguments to find a ModerationHash
     * @example
     * // Get one ModerationHash
     * const moderationHash = await prisma.moderationHash.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModerationHashFindUniqueOrThrowArgs>(args: SelectSubset<T, ModerationHashFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModerationHashClient<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModerationHash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationHashFindFirstArgs} args - Arguments to find a ModerationHash
     * @example
     * // Get one ModerationHash
     * const moderationHash = await prisma.moderationHash.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModerationHashFindFirstArgs>(args?: SelectSubset<T, ModerationHashFindFirstArgs<ExtArgs>>): Prisma__ModerationHashClient<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModerationHash that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationHashFindFirstOrThrowArgs} args - Arguments to find a ModerationHash
     * @example
     * // Get one ModerationHash
     * const moderationHash = await prisma.moderationHash.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModerationHashFindFirstOrThrowArgs>(args?: SelectSubset<T, ModerationHashFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModerationHashClient<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModerationHashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationHashFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationHashes
     * const moderationHashes = await prisma.moderationHash.findMany()
     * 
     * // Get first 10 ModerationHashes
     * const moderationHashes = await prisma.moderationHash.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationHashWithIdOnly = await prisma.moderationHash.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModerationHashFindManyArgs>(args?: SelectSubset<T, ModerationHashFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModerationHash.
     * @param {ModerationHashCreateArgs} args - Arguments to create a ModerationHash.
     * @example
     * // Create one ModerationHash
     * const ModerationHash = await prisma.moderationHash.create({
     *   data: {
     *     // ... data to create a ModerationHash
     *   }
     * })
     * 
     */
    create<T extends ModerationHashCreateArgs>(args: SelectSubset<T, ModerationHashCreateArgs<ExtArgs>>): Prisma__ModerationHashClient<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModerationHashes.
     * @param {ModerationHashCreateManyArgs} args - Arguments to create many ModerationHashes.
     * @example
     * // Create many ModerationHashes
     * const moderationHash = await prisma.moderationHash.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModerationHashCreateManyArgs>(args?: SelectSubset<T, ModerationHashCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModerationHashes and returns the data saved in the database.
     * @param {ModerationHashCreateManyAndReturnArgs} args - Arguments to create many ModerationHashes.
     * @example
     * // Create many ModerationHashes
     * const moderationHash = await prisma.moderationHash.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModerationHashes and only return the `id`
     * const moderationHashWithIdOnly = await prisma.moderationHash.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModerationHashCreateManyAndReturnArgs>(args?: SelectSubset<T, ModerationHashCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModerationHash.
     * @param {ModerationHashDeleteArgs} args - Arguments to delete one ModerationHash.
     * @example
     * // Delete one ModerationHash
     * const ModerationHash = await prisma.moderationHash.delete({
     *   where: {
     *     // ... filter to delete one ModerationHash
     *   }
     * })
     * 
     */
    delete<T extends ModerationHashDeleteArgs>(args: SelectSubset<T, ModerationHashDeleteArgs<ExtArgs>>): Prisma__ModerationHashClient<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModerationHash.
     * @param {ModerationHashUpdateArgs} args - Arguments to update one ModerationHash.
     * @example
     * // Update one ModerationHash
     * const moderationHash = await prisma.moderationHash.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModerationHashUpdateArgs>(args: SelectSubset<T, ModerationHashUpdateArgs<ExtArgs>>): Prisma__ModerationHashClient<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModerationHashes.
     * @param {ModerationHashDeleteManyArgs} args - Arguments to filter ModerationHashes to delete.
     * @example
     * // Delete a few ModerationHashes
     * const { count } = await prisma.moderationHash.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModerationHashDeleteManyArgs>(args?: SelectSubset<T, ModerationHashDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationHashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationHashUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationHashes
     * const moderationHash = await prisma.moderationHash.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModerationHashUpdateManyArgs>(args: SelectSubset<T, ModerationHashUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModerationHash.
     * @param {ModerationHashUpsertArgs} args - Arguments to update or create a ModerationHash.
     * @example
     * // Update or create a ModerationHash
     * const moderationHash = await prisma.moderationHash.upsert({
     *   create: {
     *     // ... data to create a ModerationHash
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationHash we want to update
     *   }
     * })
     */
    upsert<T extends ModerationHashUpsertArgs>(args: SelectSubset<T, ModerationHashUpsertArgs<ExtArgs>>): Prisma__ModerationHashClient<$Result.GetResult<Prisma.$ModerationHashPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModerationHashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationHashCountArgs} args - Arguments to filter ModerationHashes to count.
     * @example
     * // Count the number of ModerationHashes
     * const count = await prisma.moderationHash.count({
     *   where: {
     *     // ... the filter for the ModerationHashes we want to count
     *   }
     * })
    **/
    count<T extends ModerationHashCountArgs>(
      args?: Subset<T, ModerationHashCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationHashCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationHash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationHashAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationHashAggregateArgs>(args: Subset<T, ModerationHashAggregateArgs>): Prisma.PrismaPromise<GetModerationHashAggregateType<T>>

    /**
     * Group by ModerationHash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationHashGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationHashGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationHashGroupByArgs['orderBy'] }
        : { orderBy?: ModerationHashGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationHashGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationHashGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationHash model
   */
  readonly fields: ModerationHashFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationHash.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationHashClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModerationHash model
   */ 
  interface ModerationHashFieldRefs {
    readonly id: FieldRef<"ModerationHash", 'String'>
    readonly hashValue: FieldRef<"ModerationHash", 'String'>
    readonly hashType: FieldRef<"ModerationHash", 'String'>
    readonly status: FieldRef<"ModerationHash", 'String'>
    readonly reason: FieldRef<"ModerationHash", 'String'>
    readonly metadata: FieldRef<"ModerationHash", 'Json'>
    readonly createdAt: FieldRef<"ModerationHash", 'DateTime'>
    readonly updatedAt: FieldRef<"ModerationHash", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModerationHash findUnique
   */
  export type ModerationHashFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * Filter, which ModerationHash to fetch.
     */
    where: ModerationHashWhereUniqueInput
  }

  /**
   * ModerationHash findUniqueOrThrow
   */
  export type ModerationHashFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * Filter, which ModerationHash to fetch.
     */
    where: ModerationHashWhereUniqueInput
  }

  /**
   * ModerationHash findFirst
   */
  export type ModerationHashFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * Filter, which ModerationHash to fetch.
     */
    where?: ModerationHashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationHashes to fetch.
     */
    orderBy?: ModerationHashOrderByWithRelationInput | ModerationHashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationHashes.
     */
    cursor?: ModerationHashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationHashes.
     */
    distinct?: ModerationHashScalarFieldEnum | ModerationHashScalarFieldEnum[]
  }

  /**
   * ModerationHash findFirstOrThrow
   */
  export type ModerationHashFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * Filter, which ModerationHash to fetch.
     */
    where?: ModerationHashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationHashes to fetch.
     */
    orderBy?: ModerationHashOrderByWithRelationInput | ModerationHashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationHashes.
     */
    cursor?: ModerationHashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationHashes.
     */
    distinct?: ModerationHashScalarFieldEnum | ModerationHashScalarFieldEnum[]
  }

  /**
   * ModerationHash findMany
   */
  export type ModerationHashFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * Filter, which ModerationHashes to fetch.
     */
    where?: ModerationHashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationHashes to fetch.
     */
    orderBy?: ModerationHashOrderByWithRelationInput | ModerationHashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationHashes.
     */
    cursor?: ModerationHashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationHashes.
     */
    skip?: number
    distinct?: ModerationHashScalarFieldEnum | ModerationHashScalarFieldEnum[]
  }

  /**
   * ModerationHash create
   */
  export type ModerationHashCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * The data needed to create a ModerationHash.
     */
    data: XOR<ModerationHashCreateInput, ModerationHashUncheckedCreateInput>
  }

  /**
   * ModerationHash createMany
   */
  export type ModerationHashCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationHashes.
     */
    data: ModerationHashCreateManyInput | ModerationHashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModerationHash createManyAndReturn
   */
  export type ModerationHashCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModerationHashes.
     */
    data: ModerationHashCreateManyInput | ModerationHashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModerationHash update
   */
  export type ModerationHashUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * The data needed to update a ModerationHash.
     */
    data: XOR<ModerationHashUpdateInput, ModerationHashUncheckedUpdateInput>
    /**
     * Choose, which ModerationHash to update.
     */
    where: ModerationHashWhereUniqueInput
  }

  /**
   * ModerationHash updateMany
   */
  export type ModerationHashUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationHashes.
     */
    data: XOR<ModerationHashUpdateManyMutationInput, ModerationHashUncheckedUpdateManyInput>
    /**
     * Filter which ModerationHashes to update
     */
    where?: ModerationHashWhereInput
  }

  /**
   * ModerationHash upsert
   */
  export type ModerationHashUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * The filter to search for the ModerationHash to update in case it exists.
     */
    where: ModerationHashWhereUniqueInput
    /**
     * In case the ModerationHash found by the `where` argument doesn't exist, create a new ModerationHash with this data.
     */
    create: XOR<ModerationHashCreateInput, ModerationHashUncheckedCreateInput>
    /**
     * In case the ModerationHash was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationHashUpdateInput, ModerationHashUncheckedUpdateInput>
  }

  /**
   * ModerationHash delete
   */
  export type ModerationHashDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
    /**
     * Filter which ModerationHash to delete.
     */
    where: ModerationHashWhereUniqueInput
  }

  /**
   * ModerationHash deleteMany
   */
  export type ModerationHashDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationHashes to delete
     */
    where?: ModerationHashWhereInput
  }

  /**
   * ModerationHash without action
   */
  export type ModerationHashDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationHash
     */
    select?: ModerationHashSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MediaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    conversationId: 'conversationId',
    messageId: 'messageId',
    originalFilename: 'originalFilename',
    contentType: 'contentType',
    fileSize: 'fileSize',
    storagePath: 'storagePath',
    encryptionKeyHash: 'encryptionKeyHash',
    moderationHash: 'moderationHash',
    categoryId: 'categoryId',
    metadata: 'metadata',
    exifData: 'exifData',
    isCompressed: 'isCompressed',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const MediaPreviewScalarFieldEnum: {
    id: 'id',
    mediaId: 'mediaId',
    previewType: 'previewType',
    storagePath: 'storagePath',
    contentType: 'contentType',
    width: 'width',
    height: 'height',
    fileSize: 'fileSize',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type MediaPreviewScalarFieldEnum = (typeof MediaPreviewScalarFieldEnum)[keyof typeof MediaPreviewScalarFieldEnum]


  export const UserQuotaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    storageUsed: 'storageUsed',
    storageLimit: 'storageLimit',
    filesCount: 'filesCount',
    filesLimit: 'filesLimit',
    dailyUploads: 'dailyUploads',
    dailyUploadLimit: 'dailyUploadLimit',
    quotaDate: 'quotaDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserQuotaScalarFieldEnum = (typeof UserQuotaScalarFieldEnum)[keyof typeof UserQuotaScalarFieldEnum]


  export const MediaCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    allowedTypes: 'allowedTypes',
    maxFileSize: 'maxFileSize',
    compressionEnabled: 'compressionEnabled',
    previewEnabled: 'previewEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaCategoryScalarFieldEnum = (typeof MediaCategoryScalarFieldEnum)[keyof typeof MediaCategoryScalarFieldEnum]


  export const MediaAccessLogScalarFieldEnum: {
    id: 'id',
    mediaId: 'mediaId',
    userId: 'userId',
    actionType: 'actionType',
    clientIp: 'clientIp',
    userAgent: 'userAgent',
    requestMetadata: 'requestMetadata',
    accessedAt: 'accessedAt'
  };

  export type MediaAccessLogScalarFieldEnum = (typeof MediaAccessLogScalarFieldEnum)[keyof typeof MediaAccessLogScalarFieldEnum]


  export const MediaShareScalarFieldEnum: {
    id: 'id',
    mediaId: 'mediaId',
    sharedBy: 'sharedBy',
    sharedWith: 'sharedWith',
    permissionLevel: 'permissionLevel',
    sharedAt: 'sharedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive'
  };

  export type MediaShareScalarFieldEnum = (typeof MediaShareScalarFieldEnum)[keyof typeof MediaShareScalarFieldEnum]


  export const ModerationHashScalarFieldEnum: {
    id: 'id',
    hashValue: 'hashValue',
    hashType: 'hashType',
    status: 'status',
    reason: 'reason',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModerationHashScalarFieldEnum = (typeof ModerationHashScalarFieldEnum)[keyof typeof ModerationHashScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: UuidFilter<"Media"> | string
    userId?: UuidFilter<"Media"> | string
    conversationId?: UuidNullableFilter<"Media"> | string | null
    messageId?: UuidNullableFilter<"Media"> | string | null
    originalFilename?: StringFilter<"Media"> | string
    contentType?: StringFilter<"Media"> | string
    fileSize?: BigIntFilter<"Media"> | bigint | number
    storagePath?: StringFilter<"Media"> | string
    encryptionKeyHash?: StringFilter<"Media"> | string
    moderationHash?: StringFilter<"Media"> | string
    categoryId?: UuidFilter<"Media"> | string
    metadata?: JsonFilter<"Media">
    exifData?: JsonFilter<"Media">
    isCompressed?: BoolFilter<"Media"> | boolean
    isActive?: BoolFilter<"Media"> | boolean
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    category?: XOR<MediaCategoryRelationFilter, MediaCategoryWhereInput>
    previews?: MediaPreviewListRelationFilter
    accessLogs?: MediaAccessLogListRelationFilter
    shares?: MediaShareListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    originalFilename?: SortOrder
    contentType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    encryptionKeyHash?: SortOrder
    moderationHash?: SortOrder
    categoryId?: SortOrder
    metadata?: SortOrder
    exifData?: SortOrder
    isCompressed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    category?: MediaCategoryOrderByWithRelationInput
    previews?: MediaPreviewOrderByRelationAggregateInput
    accessLogs?: MediaAccessLogOrderByRelationAggregateInput
    shares?: MediaShareOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storagePath?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    userId?: UuidFilter<"Media"> | string
    conversationId?: UuidNullableFilter<"Media"> | string | null
    messageId?: UuidNullableFilter<"Media"> | string | null
    originalFilename?: StringFilter<"Media"> | string
    contentType?: StringFilter<"Media"> | string
    fileSize?: BigIntFilter<"Media"> | bigint | number
    encryptionKeyHash?: StringFilter<"Media"> | string
    moderationHash?: StringFilter<"Media"> | string
    categoryId?: UuidFilter<"Media"> | string
    metadata?: JsonFilter<"Media">
    exifData?: JsonFilter<"Media">
    isCompressed?: BoolFilter<"Media"> | boolean
    isActive?: BoolFilter<"Media"> | boolean
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    category?: XOR<MediaCategoryRelationFilter, MediaCategoryWhereInput>
    previews?: MediaPreviewListRelationFilter
    accessLogs?: MediaAccessLogListRelationFilter
    shares?: MediaShareListRelationFilter
  }, "id" | "storagePath">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    originalFilename?: SortOrder
    contentType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    encryptionKeyHash?: SortOrder
    moderationHash?: SortOrder
    categoryId?: SortOrder
    metadata?: SortOrder
    exifData?: SortOrder
    isCompressed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Media"> | string
    userId?: UuidWithAggregatesFilter<"Media"> | string
    conversationId?: UuidNullableWithAggregatesFilter<"Media"> | string | null
    messageId?: UuidNullableWithAggregatesFilter<"Media"> | string | null
    originalFilename?: StringWithAggregatesFilter<"Media"> | string
    contentType?: StringWithAggregatesFilter<"Media"> | string
    fileSize?: BigIntWithAggregatesFilter<"Media"> | bigint | number
    storagePath?: StringWithAggregatesFilter<"Media"> | string
    encryptionKeyHash?: StringWithAggregatesFilter<"Media"> | string
    moderationHash?: StringWithAggregatesFilter<"Media"> | string
    categoryId?: UuidWithAggregatesFilter<"Media"> | string
    metadata?: JsonWithAggregatesFilter<"Media">
    exifData?: JsonWithAggregatesFilter<"Media">
    isCompressed?: BoolWithAggregatesFilter<"Media"> | boolean
    isActive?: BoolWithAggregatesFilter<"Media"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Media"> | Date | string | null
  }

  export type MediaPreviewWhereInput = {
    AND?: MediaPreviewWhereInput | MediaPreviewWhereInput[]
    OR?: MediaPreviewWhereInput[]
    NOT?: MediaPreviewWhereInput | MediaPreviewWhereInput[]
    id?: UuidFilter<"MediaPreview"> | string
    mediaId?: UuidFilter<"MediaPreview"> | string
    previewType?: StringFilter<"MediaPreview"> | string
    storagePath?: StringFilter<"MediaPreview"> | string
    contentType?: StringFilter<"MediaPreview"> | string
    width?: IntNullableFilter<"MediaPreview"> | number | null
    height?: IntNullableFilter<"MediaPreview"> | number | null
    fileSize?: BigIntFilter<"MediaPreview"> | bigint | number
    metadata?: JsonFilter<"MediaPreview">
    createdAt?: DateTimeFilter<"MediaPreview"> | Date | string
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }

  export type MediaPreviewOrderByWithRelationInput = {
    id?: SortOrder
    mediaId?: SortOrder
    previewType?: SortOrder
    storagePath?: SortOrder
    contentType?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    fileSize?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    media?: MediaOrderByWithRelationInput
  }

  export type MediaPreviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaPreviewWhereInput | MediaPreviewWhereInput[]
    OR?: MediaPreviewWhereInput[]
    NOT?: MediaPreviewWhereInput | MediaPreviewWhereInput[]
    mediaId?: UuidFilter<"MediaPreview"> | string
    previewType?: StringFilter<"MediaPreview"> | string
    storagePath?: StringFilter<"MediaPreview"> | string
    contentType?: StringFilter<"MediaPreview"> | string
    width?: IntNullableFilter<"MediaPreview"> | number | null
    height?: IntNullableFilter<"MediaPreview"> | number | null
    fileSize?: BigIntFilter<"MediaPreview"> | bigint | number
    metadata?: JsonFilter<"MediaPreview">
    createdAt?: DateTimeFilter<"MediaPreview"> | Date | string
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }, "id">

  export type MediaPreviewOrderByWithAggregationInput = {
    id?: SortOrder
    mediaId?: SortOrder
    previewType?: SortOrder
    storagePath?: SortOrder
    contentType?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    fileSize?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: MediaPreviewCountOrderByAggregateInput
    _avg?: MediaPreviewAvgOrderByAggregateInput
    _max?: MediaPreviewMaxOrderByAggregateInput
    _min?: MediaPreviewMinOrderByAggregateInput
    _sum?: MediaPreviewSumOrderByAggregateInput
  }

  export type MediaPreviewScalarWhereWithAggregatesInput = {
    AND?: MediaPreviewScalarWhereWithAggregatesInput | MediaPreviewScalarWhereWithAggregatesInput[]
    OR?: MediaPreviewScalarWhereWithAggregatesInput[]
    NOT?: MediaPreviewScalarWhereWithAggregatesInput | MediaPreviewScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MediaPreview"> | string
    mediaId?: UuidWithAggregatesFilter<"MediaPreview"> | string
    previewType?: StringWithAggregatesFilter<"MediaPreview"> | string
    storagePath?: StringWithAggregatesFilter<"MediaPreview"> | string
    contentType?: StringWithAggregatesFilter<"MediaPreview"> | string
    width?: IntNullableWithAggregatesFilter<"MediaPreview"> | number | null
    height?: IntNullableWithAggregatesFilter<"MediaPreview"> | number | null
    fileSize?: BigIntWithAggregatesFilter<"MediaPreview"> | bigint | number
    metadata?: JsonWithAggregatesFilter<"MediaPreview">
    createdAt?: DateTimeWithAggregatesFilter<"MediaPreview"> | Date | string
  }

  export type UserQuotaWhereInput = {
    AND?: UserQuotaWhereInput | UserQuotaWhereInput[]
    OR?: UserQuotaWhereInput[]
    NOT?: UserQuotaWhereInput | UserQuotaWhereInput[]
    id?: UuidFilter<"UserQuota"> | string
    userId?: UuidFilter<"UserQuota"> | string
    storageUsed?: BigIntFilter<"UserQuota"> | bigint | number
    storageLimit?: BigIntFilter<"UserQuota"> | bigint | number
    filesCount?: IntFilter<"UserQuota"> | number
    filesLimit?: IntFilter<"UserQuota"> | number
    dailyUploads?: IntFilter<"UserQuota"> | number
    dailyUploadLimit?: IntFilter<"UserQuota"> | number
    quotaDate?: DateTimeFilter<"UserQuota"> | Date | string
    createdAt?: DateTimeFilter<"UserQuota"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuota"> | Date | string
  }

  export type UserQuotaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    storageUsed?: SortOrder
    storageLimit?: SortOrder
    filesCount?: SortOrder
    filesLimit?: SortOrder
    dailyUploads?: SortOrder
    dailyUploadLimit?: SortOrder
    quotaDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserQuotaWhereInput | UserQuotaWhereInput[]
    OR?: UserQuotaWhereInput[]
    NOT?: UserQuotaWhereInput | UserQuotaWhereInput[]
    storageUsed?: BigIntFilter<"UserQuota"> | bigint | number
    storageLimit?: BigIntFilter<"UserQuota"> | bigint | number
    filesCount?: IntFilter<"UserQuota"> | number
    filesLimit?: IntFilter<"UserQuota"> | number
    dailyUploads?: IntFilter<"UserQuota"> | number
    dailyUploadLimit?: IntFilter<"UserQuota"> | number
    quotaDate?: DateTimeFilter<"UserQuota"> | Date | string
    createdAt?: DateTimeFilter<"UserQuota"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuota"> | Date | string
  }, "id" | "userId">

  export type UserQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    storageUsed?: SortOrder
    storageLimit?: SortOrder
    filesCount?: SortOrder
    filesLimit?: SortOrder
    dailyUploads?: SortOrder
    dailyUploadLimit?: SortOrder
    quotaDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserQuotaCountOrderByAggregateInput
    _avg?: UserQuotaAvgOrderByAggregateInput
    _max?: UserQuotaMaxOrderByAggregateInput
    _min?: UserQuotaMinOrderByAggregateInput
    _sum?: UserQuotaSumOrderByAggregateInput
  }

  export type UserQuotaScalarWhereWithAggregatesInput = {
    AND?: UserQuotaScalarWhereWithAggregatesInput | UserQuotaScalarWhereWithAggregatesInput[]
    OR?: UserQuotaScalarWhereWithAggregatesInput[]
    NOT?: UserQuotaScalarWhereWithAggregatesInput | UserQuotaScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserQuota"> | string
    userId?: UuidWithAggregatesFilter<"UserQuota"> | string
    storageUsed?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    storageLimit?: BigIntWithAggregatesFilter<"UserQuota"> | bigint | number
    filesCount?: IntWithAggregatesFilter<"UserQuota"> | number
    filesLimit?: IntWithAggregatesFilter<"UserQuota"> | number
    dailyUploads?: IntWithAggregatesFilter<"UserQuota"> | number
    dailyUploadLimit?: IntWithAggregatesFilter<"UserQuota"> | number
    quotaDate?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserQuota"> | Date | string
  }

  export type MediaCategoryWhereInput = {
    AND?: MediaCategoryWhereInput | MediaCategoryWhereInput[]
    OR?: MediaCategoryWhereInput[]
    NOT?: MediaCategoryWhereInput | MediaCategoryWhereInput[]
    id?: UuidFilter<"MediaCategory"> | string
    name?: StringFilter<"MediaCategory"> | string
    description?: StringNullableFilter<"MediaCategory"> | string | null
    allowedTypes?: JsonFilter<"MediaCategory">
    maxFileSize?: BigIntFilter<"MediaCategory"> | bigint | number
    compressionEnabled?: BoolFilter<"MediaCategory"> | boolean
    previewEnabled?: BoolFilter<"MediaCategory"> | boolean
    createdAt?: DateTimeFilter<"MediaCategory"> | Date | string
    updatedAt?: DateTimeFilter<"MediaCategory"> | Date | string
    media?: MediaListRelationFilter
  }

  export type MediaCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    allowedTypes?: SortOrder
    maxFileSize?: SortOrder
    compressionEnabled?: SortOrder
    previewEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    media?: MediaOrderByRelationAggregateInput
  }

  export type MediaCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MediaCategoryWhereInput | MediaCategoryWhereInput[]
    OR?: MediaCategoryWhereInput[]
    NOT?: MediaCategoryWhereInput | MediaCategoryWhereInput[]
    description?: StringNullableFilter<"MediaCategory"> | string | null
    allowedTypes?: JsonFilter<"MediaCategory">
    maxFileSize?: BigIntFilter<"MediaCategory"> | bigint | number
    compressionEnabled?: BoolFilter<"MediaCategory"> | boolean
    previewEnabled?: BoolFilter<"MediaCategory"> | boolean
    createdAt?: DateTimeFilter<"MediaCategory"> | Date | string
    updatedAt?: DateTimeFilter<"MediaCategory"> | Date | string
    media?: MediaListRelationFilter
  }, "id" | "name">

  export type MediaCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    allowedTypes?: SortOrder
    maxFileSize?: SortOrder
    compressionEnabled?: SortOrder
    previewEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaCategoryCountOrderByAggregateInput
    _avg?: MediaCategoryAvgOrderByAggregateInput
    _max?: MediaCategoryMaxOrderByAggregateInput
    _min?: MediaCategoryMinOrderByAggregateInput
    _sum?: MediaCategorySumOrderByAggregateInput
  }

  export type MediaCategoryScalarWhereWithAggregatesInput = {
    AND?: MediaCategoryScalarWhereWithAggregatesInput | MediaCategoryScalarWhereWithAggregatesInput[]
    OR?: MediaCategoryScalarWhereWithAggregatesInput[]
    NOT?: MediaCategoryScalarWhereWithAggregatesInput | MediaCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MediaCategory"> | string
    name?: StringWithAggregatesFilter<"MediaCategory"> | string
    description?: StringNullableWithAggregatesFilter<"MediaCategory"> | string | null
    allowedTypes?: JsonWithAggregatesFilter<"MediaCategory">
    maxFileSize?: BigIntWithAggregatesFilter<"MediaCategory"> | bigint | number
    compressionEnabled?: BoolWithAggregatesFilter<"MediaCategory"> | boolean
    previewEnabled?: BoolWithAggregatesFilter<"MediaCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MediaCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaCategory"> | Date | string
  }

  export type MediaAccessLogWhereInput = {
    AND?: MediaAccessLogWhereInput | MediaAccessLogWhereInput[]
    OR?: MediaAccessLogWhereInput[]
    NOT?: MediaAccessLogWhereInput | MediaAccessLogWhereInput[]
    id?: UuidFilter<"MediaAccessLog"> | string
    mediaId?: UuidFilter<"MediaAccessLog"> | string
    userId?: UuidFilter<"MediaAccessLog"> | string
    actionType?: StringFilter<"MediaAccessLog"> | string
    clientIp?: StringNullableFilter<"MediaAccessLog"> | string | null
    userAgent?: StringNullableFilter<"MediaAccessLog"> | string | null
    requestMetadata?: JsonFilter<"MediaAccessLog">
    accessedAt?: DateTimeFilter<"MediaAccessLog"> | Date | string
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }

  export type MediaAccessLogOrderByWithRelationInput = {
    id?: SortOrder
    mediaId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    clientIp?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestMetadata?: SortOrder
    accessedAt?: SortOrder
    media?: MediaOrderByWithRelationInput
  }

  export type MediaAccessLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaAccessLogWhereInput | MediaAccessLogWhereInput[]
    OR?: MediaAccessLogWhereInput[]
    NOT?: MediaAccessLogWhereInput | MediaAccessLogWhereInput[]
    mediaId?: UuidFilter<"MediaAccessLog"> | string
    userId?: UuidFilter<"MediaAccessLog"> | string
    actionType?: StringFilter<"MediaAccessLog"> | string
    clientIp?: StringNullableFilter<"MediaAccessLog"> | string | null
    userAgent?: StringNullableFilter<"MediaAccessLog"> | string | null
    requestMetadata?: JsonFilter<"MediaAccessLog">
    accessedAt?: DateTimeFilter<"MediaAccessLog"> | Date | string
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }, "id">

  export type MediaAccessLogOrderByWithAggregationInput = {
    id?: SortOrder
    mediaId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    clientIp?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestMetadata?: SortOrder
    accessedAt?: SortOrder
    _count?: MediaAccessLogCountOrderByAggregateInput
    _max?: MediaAccessLogMaxOrderByAggregateInput
    _min?: MediaAccessLogMinOrderByAggregateInput
  }

  export type MediaAccessLogScalarWhereWithAggregatesInput = {
    AND?: MediaAccessLogScalarWhereWithAggregatesInput | MediaAccessLogScalarWhereWithAggregatesInput[]
    OR?: MediaAccessLogScalarWhereWithAggregatesInput[]
    NOT?: MediaAccessLogScalarWhereWithAggregatesInput | MediaAccessLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MediaAccessLog"> | string
    mediaId?: UuidWithAggregatesFilter<"MediaAccessLog"> | string
    userId?: UuidWithAggregatesFilter<"MediaAccessLog"> | string
    actionType?: StringWithAggregatesFilter<"MediaAccessLog"> | string
    clientIp?: StringNullableWithAggregatesFilter<"MediaAccessLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"MediaAccessLog"> | string | null
    requestMetadata?: JsonWithAggregatesFilter<"MediaAccessLog">
    accessedAt?: DateTimeWithAggregatesFilter<"MediaAccessLog"> | Date | string
  }

  export type MediaShareWhereInput = {
    AND?: MediaShareWhereInput | MediaShareWhereInput[]
    OR?: MediaShareWhereInput[]
    NOT?: MediaShareWhereInput | MediaShareWhereInput[]
    id?: UuidFilter<"MediaShare"> | string
    mediaId?: UuidFilter<"MediaShare"> | string
    sharedBy?: UuidFilter<"MediaShare"> | string
    sharedWith?: UuidFilter<"MediaShare"> | string
    permissionLevel?: StringFilter<"MediaShare"> | string
    sharedAt?: DateTimeFilter<"MediaShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MediaShare"> | Date | string | null
    isActive?: BoolFilter<"MediaShare"> | boolean
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }

  export type MediaShareOrderByWithRelationInput = {
    id?: SortOrder
    mediaId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permissionLevel?: SortOrder
    sharedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    media?: MediaOrderByWithRelationInput
  }

  export type MediaShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaShareWhereInput | MediaShareWhereInput[]
    OR?: MediaShareWhereInput[]
    NOT?: MediaShareWhereInput | MediaShareWhereInput[]
    mediaId?: UuidFilter<"MediaShare"> | string
    sharedBy?: UuidFilter<"MediaShare"> | string
    sharedWith?: UuidFilter<"MediaShare"> | string
    permissionLevel?: StringFilter<"MediaShare"> | string
    sharedAt?: DateTimeFilter<"MediaShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MediaShare"> | Date | string | null
    isActive?: BoolFilter<"MediaShare"> | boolean
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }, "id">

  export type MediaShareOrderByWithAggregationInput = {
    id?: SortOrder
    mediaId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permissionLevel?: SortOrder
    sharedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: MediaShareCountOrderByAggregateInput
    _max?: MediaShareMaxOrderByAggregateInput
    _min?: MediaShareMinOrderByAggregateInput
  }

  export type MediaShareScalarWhereWithAggregatesInput = {
    AND?: MediaShareScalarWhereWithAggregatesInput | MediaShareScalarWhereWithAggregatesInput[]
    OR?: MediaShareScalarWhereWithAggregatesInput[]
    NOT?: MediaShareScalarWhereWithAggregatesInput | MediaShareScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MediaShare"> | string
    mediaId?: UuidWithAggregatesFilter<"MediaShare"> | string
    sharedBy?: UuidWithAggregatesFilter<"MediaShare"> | string
    sharedWith?: UuidWithAggregatesFilter<"MediaShare"> | string
    permissionLevel?: StringWithAggregatesFilter<"MediaShare"> | string
    sharedAt?: DateTimeWithAggregatesFilter<"MediaShare"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"MediaShare"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"MediaShare"> | boolean
  }

  export type ModerationHashWhereInput = {
    AND?: ModerationHashWhereInput | ModerationHashWhereInput[]
    OR?: ModerationHashWhereInput[]
    NOT?: ModerationHashWhereInput | ModerationHashWhereInput[]
    id?: UuidFilter<"ModerationHash"> | string
    hashValue?: StringFilter<"ModerationHash"> | string
    hashType?: StringFilter<"ModerationHash"> | string
    status?: StringFilter<"ModerationHash"> | string
    reason?: StringNullableFilter<"ModerationHash"> | string | null
    metadata?: JsonFilter<"ModerationHash">
    createdAt?: DateTimeFilter<"ModerationHash"> | Date | string
    updatedAt?: DateTimeFilter<"ModerationHash"> | Date | string
  }

  export type ModerationHashOrderByWithRelationInput = {
    id?: SortOrder
    hashValue?: SortOrder
    hashType?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModerationHashWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hashValue?: string
    AND?: ModerationHashWhereInput | ModerationHashWhereInput[]
    OR?: ModerationHashWhereInput[]
    NOT?: ModerationHashWhereInput | ModerationHashWhereInput[]
    hashType?: StringFilter<"ModerationHash"> | string
    status?: StringFilter<"ModerationHash"> | string
    reason?: StringNullableFilter<"ModerationHash"> | string | null
    metadata?: JsonFilter<"ModerationHash">
    createdAt?: DateTimeFilter<"ModerationHash"> | Date | string
    updatedAt?: DateTimeFilter<"ModerationHash"> | Date | string
  }, "id" | "hashValue">

  export type ModerationHashOrderByWithAggregationInput = {
    id?: SortOrder
    hashValue?: SortOrder
    hashType?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModerationHashCountOrderByAggregateInput
    _max?: ModerationHashMaxOrderByAggregateInput
    _min?: ModerationHashMinOrderByAggregateInput
  }

  export type ModerationHashScalarWhereWithAggregatesInput = {
    AND?: ModerationHashScalarWhereWithAggregatesInput | ModerationHashScalarWhereWithAggregatesInput[]
    OR?: ModerationHashScalarWhereWithAggregatesInput[]
    NOT?: ModerationHashScalarWhereWithAggregatesInput | ModerationHashScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ModerationHash"> | string
    hashValue?: StringWithAggregatesFilter<"ModerationHash"> | string
    hashType?: StringWithAggregatesFilter<"ModerationHash"> | string
    status?: StringWithAggregatesFilter<"ModerationHash"> | string
    reason?: StringNullableWithAggregatesFilter<"ModerationHash"> | string | null
    metadata?: JsonWithAggregatesFilter<"ModerationHash">
    createdAt?: DateTimeWithAggregatesFilter<"ModerationHash"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModerationHash"> | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    category: MediaCategoryCreateNestedOneWithoutMediaInput
    previews?: MediaPreviewCreateNestedManyWithoutMediaInput
    accessLogs?: MediaAccessLogCreateNestedManyWithoutMediaInput
    shares?: MediaShareCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    categoryId: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    previews?: MediaPreviewUncheckedCreateNestedManyWithoutMediaInput
    accessLogs?: MediaAccessLogUncheckedCreateNestedManyWithoutMediaInput
    shares?: MediaShareUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: MediaCategoryUpdateOneRequiredWithoutMediaNestedInput
    previews?: MediaPreviewUpdateManyWithoutMediaNestedInput
    accessLogs?: MediaAccessLogUpdateManyWithoutMediaNestedInput
    shares?: MediaShareUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previews?: MediaPreviewUncheckedUpdateManyWithoutMediaNestedInput
    accessLogs?: MediaAccessLogUncheckedUpdateManyWithoutMediaNestedInput
    shares?: MediaShareUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    categoryId: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaPreviewCreateInput = {
    id?: string
    previewType: string
    storagePath: string
    contentType: string
    width?: number | null
    height?: number | null
    fileSize: bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    media: MediaCreateNestedOneWithoutPreviewsInput
  }

  export type MediaPreviewUncheckedCreateInput = {
    id?: string
    mediaId: string
    previewType: string
    storagePath: string
    contentType: string
    width?: number | null
    height?: number | null
    fileSize: bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaPreviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    previewType?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutPreviewsNestedInput
  }

  export type MediaPreviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    previewType?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPreviewCreateManyInput = {
    id?: string
    mediaId: string
    previewType: string
    storagePath: string
    contentType: string
    width?: number | null
    height?: number | null
    fileSize: bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaPreviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    previewType?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPreviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    previewType?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaCreateInput = {
    id?: string
    userId: string
    storageUsed?: bigint | number
    storageLimit?: bigint | number
    filesCount?: number
    filesLimit?: number
    dailyUploads?: number
    dailyUploadLimit?: number
    quotaDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuotaUncheckedCreateInput = {
    id?: string
    userId: string
    storageUsed?: bigint | number
    storageLimit?: bigint | number
    filesCount?: number
    filesLimit?: number
    dailyUploads?: number
    dailyUploadLimit?: number
    quotaDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storageUsed?: BigIntFieldUpdateOperationsInput | bigint | number
    storageLimit?: BigIntFieldUpdateOperationsInput | bigint | number
    filesCount?: IntFieldUpdateOperationsInput | number
    filesLimit?: IntFieldUpdateOperationsInput | number
    dailyUploads?: IntFieldUpdateOperationsInput | number
    dailyUploadLimit?: IntFieldUpdateOperationsInput | number
    quotaDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storageUsed?: BigIntFieldUpdateOperationsInput | bigint | number
    storageLimit?: BigIntFieldUpdateOperationsInput | bigint | number
    filesCount?: IntFieldUpdateOperationsInput | number
    filesLimit?: IntFieldUpdateOperationsInput | number
    dailyUploads?: IntFieldUpdateOperationsInput | number
    dailyUploadLimit?: IntFieldUpdateOperationsInput | number
    quotaDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaCreateManyInput = {
    id?: string
    userId: string
    storageUsed?: bigint | number
    storageLimit?: bigint | number
    filesCount?: number
    filesLimit?: number
    dailyUploads?: number
    dailyUploadLimit?: number
    quotaDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storageUsed?: BigIntFieldUpdateOperationsInput | bigint | number
    storageLimit?: BigIntFieldUpdateOperationsInput | bigint | number
    filesCount?: IntFieldUpdateOperationsInput | number
    filesLimit?: IntFieldUpdateOperationsInput | number
    dailyUploads?: IntFieldUpdateOperationsInput | number
    dailyUploadLimit?: IntFieldUpdateOperationsInput | number
    quotaDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storageUsed?: BigIntFieldUpdateOperationsInput | bigint | number
    storageLimit?: BigIntFieldUpdateOperationsInput | bigint | number
    filesCount?: IntFieldUpdateOperationsInput | number
    filesLimit?: IntFieldUpdateOperationsInput | number
    dailyUploads?: IntFieldUpdateOperationsInput | number
    dailyUploadLimit?: IntFieldUpdateOperationsInput | number
    quotaDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize: bigint | number
    compressionEnabled?: boolean
    previewEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaCreateNestedManyWithoutCategoryInput
  }

  export type MediaCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize: bigint | number
    compressionEnabled?: boolean
    previewEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type MediaCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    compressionEnabled?: BoolFieldUpdateOperationsInput | boolean
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateManyWithoutCategoryNestedInput
  }

  export type MediaCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    compressionEnabled?: BoolFieldUpdateOperationsInput | boolean
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type MediaCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize: bigint | number
    compressionEnabled?: boolean
    previewEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    compressionEnabled?: BoolFieldUpdateOperationsInput | boolean
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    compressionEnabled?: BoolFieldUpdateOperationsInput | boolean
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAccessLogCreateInput = {
    id?: string
    userId: string
    actionType: string
    clientIp?: string | null
    userAgent?: string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: Date | string
    media: MediaCreateNestedOneWithoutAccessLogsInput
  }

  export type MediaAccessLogUncheckedCreateInput = {
    id?: string
    mediaId: string
    userId: string
    actionType: string
    clientIp?: string | null
    userAgent?: string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: Date | string
  }

  export type MediaAccessLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutAccessLogsNestedInput
  }

  export type MediaAccessLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAccessLogCreateManyInput = {
    id?: string
    mediaId: string
    userId: string
    actionType: string
    clientIp?: string | null
    userAgent?: string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: Date | string
  }

  export type MediaAccessLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAccessLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaShareCreateInput = {
    id?: string
    sharedBy: string
    sharedWith: string
    permissionLevel: string
    sharedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    media: MediaCreateNestedOneWithoutSharesInput
  }

  export type MediaShareUncheckedCreateInput = {
    id?: string
    mediaId: string
    sharedBy: string
    sharedWith: string
    permissionLevel: string
    sharedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type MediaShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissionLevel?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    media?: MediaUpdateOneRequiredWithoutSharesNestedInput
  }

  export type MediaShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissionLevel?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MediaShareCreateManyInput = {
    id?: string
    mediaId: string
    sharedBy: string
    sharedWith: string
    permissionLevel: string
    sharedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type MediaShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissionLevel?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MediaShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissionLevel?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModerationHashCreateInput = {
    id?: string
    hashValue: string
    hashType: string
    status: string
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModerationHashUncheckedCreateInput = {
    id?: string
    hashValue: string
    hashType: string
    status: string
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModerationHashUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashValue?: StringFieldUpdateOperationsInput | string
    hashType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationHashUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashValue?: StringFieldUpdateOperationsInput | string
    hashType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationHashCreateManyInput = {
    id?: string
    hashValue: string
    hashType: string
    status: string
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModerationHashUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashValue?: StringFieldUpdateOperationsInput | string
    hashType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationHashUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashValue?: StringFieldUpdateOperationsInput | string
    hashType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MediaCategoryRelationFilter = {
    is?: MediaCategoryWhereInput
    isNot?: MediaCategoryWhereInput
  }

  export type MediaPreviewListRelationFilter = {
    every?: MediaPreviewWhereInput
    some?: MediaPreviewWhereInput
    none?: MediaPreviewWhereInput
  }

  export type MediaAccessLogListRelationFilter = {
    every?: MediaAccessLogWhereInput
    some?: MediaAccessLogWhereInput
    none?: MediaAccessLogWhereInput
  }

  export type MediaShareListRelationFilter = {
    every?: MediaShareWhereInput
    some?: MediaShareWhereInput
    none?: MediaShareWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MediaPreviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaAccessLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    originalFilename?: SortOrder
    contentType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    encryptionKeyHash?: SortOrder
    moderationHash?: SortOrder
    categoryId?: SortOrder
    metadata?: SortOrder
    exifData?: SortOrder
    isCompressed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    originalFilename?: SortOrder
    contentType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    encryptionKeyHash?: SortOrder
    moderationHash?: SortOrder
    categoryId?: SortOrder
    isCompressed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    originalFilename?: SortOrder
    contentType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    encryptionKeyHash?: SortOrder
    moderationHash?: SortOrder
    categoryId?: SortOrder
    isCompressed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MediaRelationFilter = {
    is?: MediaWhereInput
    isNot?: MediaWhereInput
  }

  export type MediaPreviewCountOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    previewType?: SortOrder
    storagePath?: SortOrder
    contentType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaPreviewAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
  }

  export type MediaPreviewMaxOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    previewType?: SortOrder
    storagePath?: SortOrder
    contentType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaPreviewMinOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    previewType?: SortOrder
    storagePath?: SortOrder
    contentType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaPreviewSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    fileSize?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageUsed?: SortOrder
    storageLimit?: SortOrder
    filesCount?: SortOrder
    filesLimit?: SortOrder
    dailyUploads?: SortOrder
    dailyUploadLimit?: SortOrder
    quotaDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuotaAvgOrderByAggregateInput = {
    storageUsed?: SortOrder
    storageLimit?: SortOrder
    filesCount?: SortOrder
    filesLimit?: SortOrder
    dailyUploads?: SortOrder
    dailyUploadLimit?: SortOrder
  }

  export type UserQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageUsed?: SortOrder
    storageLimit?: SortOrder
    filesCount?: SortOrder
    filesLimit?: SortOrder
    dailyUploads?: SortOrder
    dailyUploadLimit?: SortOrder
    quotaDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageUsed?: SortOrder
    storageLimit?: SortOrder
    filesCount?: SortOrder
    filesLimit?: SortOrder
    dailyUploads?: SortOrder
    dailyUploadLimit?: SortOrder
    quotaDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuotaSumOrderByAggregateInput = {
    storageUsed?: SortOrder
    storageLimit?: SortOrder
    filesCount?: SortOrder
    filesLimit?: SortOrder
    dailyUploads?: SortOrder
    dailyUploadLimit?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    allowedTypes?: SortOrder
    maxFileSize?: SortOrder
    compressionEnabled?: SortOrder
    previewEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaCategoryAvgOrderByAggregateInput = {
    maxFileSize?: SortOrder
  }

  export type MediaCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxFileSize?: SortOrder
    compressionEnabled?: SortOrder
    previewEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxFileSize?: SortOrder
    compressionEnabled?: SortOrder
    previewEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaCategorySumOrderByAggregateInput = {
    maxFileSize?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MediaAccessLogCountOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    clientIp?: SortOrder
    userAgent?: SortOrder
    requestMetadata?: SortOrder
    accessedAt?: SortOrder
  }

  export type MediaAccessLogMaxOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    clientIp?: SortOrder
    userAgent?: SortOrder
    accessedAt?: SortOrder
  }

  export type MediaAccessLogMinOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    clientIp?: SortOrder
    userAgent?: SortOrder
    accessedAt?: SortOrder
  }

  export type MediaShareCountOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permissionLevel?: SortOrder
    sharedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type MediaShareMaxOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permissionLevel?: SortOrder
    sharedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type MediaShareMinOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    sharedBy?: SortOrder
    sharedWith?: SortOrder
    permissionLevel?: SortOrder
    sharedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ModerationHashCountOrderByAggregateInput = {
    id?: SortOrder
    hashValue?: SortOrder
    hashType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModerationHashMaxOrderByAggregateInput = {
    id?: SortOrder
    hashValue?: SortOrder
    hashType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModerationHashMinOrderByAggregateInput = {
    id?: SortOrder
    hashValue?: SortOrder
    hashType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaCategoryCreateNestedOneWithoutMediaInput = {
    create?: XOR<MediaCategoryCreateWithoutMediaInput, MediaCategoryUncheckedCreateWithoutMediaInput>
    connectOrCreate?: MediaCategoryCreateOrConnectWithoutMediaInput
    connect?: MediaCategoryWhereUniqueInput
  }

  export type MediaPreviewCreateNestedManyWithoutMediaInput = {
    create?: XOR<MediaPreviewCreateWithoutMediaInput, MediaPreviewUncheckedCreateWithoutMediaInput> | MediaPreviewCreateWithoutMediaInput[] | MediaPreviewUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaPreviewCreateOrConnectWithoutMediaInput | MediaPreviewCreateOrConnectWithoutMediaInput[]
    createMany?: MediaPreviewCreateManyMediaInputEnvelope
    connect?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
  }

  export type MediaAccessLogCreateNestedManyWithoutMediaInput = {
    create?: XOR<MediaAccessLogCreateWithoutMediaInput, MediaAccessLogUncheckedCreateWithoutMediaInput> | MediaAccessLogCreateWithoutMediaInput[] | MediaAccessLogUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaAccessLogCreateOrConnectWithoutMediaInput | MediaAccessLogCreateOrConnectWithoutMediaInput[]
    createMany?: MediaAccessLogCreateManyMediaInputEnvelope
    connect?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
  }

  export type MediaShareCreateNestedManyWithoutMediaInput = {
    create?: XOR<MediaShareCreateWithoutMediaInput, MediaShareUncheckedCreateWithoutMediaInput> | MediaShareCreateWithoutMediaInput[] | MediaShareUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaShareCreateOrConnectWithoutMediaInput | MediaShareCreateOrConnectWithoutMediaInput[]
    createMany?: MediaShareCreateManyMediaInputEnvelope
    connect?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
  }

  export type MediaPreviewUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<MediaPreviewCreateWithoutMediaInput, MediaPreviewUncheckedCreateWithoutMediaInput> | MediaPreviewCreateWithoutMediaInput[] | MediaPreviewUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaPreviewCreateOrConnectWithoutMediaInput | MediaPreviewCreateOrConnectWithoutMediaInput[]
    createMany?: MediaPreviewCreateManyMediaInputEnvelope
    connect?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
  }

  export type MediaAccessLogUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<MediaAccessLogCreateWithoutMediaInput, MediaAccessLogUncheckedCreateWithoutMediaInput> | MediaAccessLogCreateWithoutMediaInput[] | MediaAccessLogUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaAccessLogCreateOrConnectWithoutMediaInput | MediaAccessLogCreateOrConnectWithoutMediaInput[]
    createMany?: MediaAccessLogCreateManyMediaInputEnvelope
    connect?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
  }

  export type MediaShareUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<MediaShareCreateWithoutMediaInput, MediaShareUncheckedCreateWithoutMediaInput> | MediaShareCreateWithoutMediaInput[] | MediaShareUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaShareCreateOrConnectWithoutMediaInput | MediaShareCreateOrConnectWithoutMediaInput[]
    createMany?: MediaShareCreateManyMediaInputEnvelope
    connect?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MediaCategoryUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<MediaCategoryCreateWithoutMediaInput, MediaCategoryUncheckedCreateWithoutMediaInput>
    connectOrCreate?: MediaCategoryCreateOrConnectWithoutMediaInput
    upsert?: MediaCategoryUpsertWithoutMediaInput
    connect?: MediaCategoryWhereUniqueInput
    update?: XOR<XOR<MediaCategoryUpdateToOneWithWhereWithoutMediaInput, MediaCategoryUpdateWithoutMediaInput>, MediaCategoryUncheckedUpdateWithoutMediaInput>
  }

  export type MediaPreviewUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MediaPreviewCreateWithoutMediaInput, MediaPreviewUncheckedCreateWithoutMediaInput> | MediaPreviewCreateWithoutMediaInput[] | MediaPreviewUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaPreviewCreateOrConnectWithoutMediaInput | MediaPreviewCreateOrConnectWithoutMediaInput[]
    upsert?: MediaPreviewUpsertWithWhereUniqueWithoutMediaInput | MediaPreviewUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MediaPreviewCreateManyMediaInputEnvelope
    set?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
    disconnect?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
    delete?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
    connect?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
    update?: MediaPreviewUpdateWithWhereUniqueWithoutMediaInput | MediaPreviewUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MediaPreviewUpdateManyWithWhereWithoutMediaInput | MediaPreviewUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MediaPreviewScalarWhereInput | MediaPreviewScalarWhereInput[]
  }

  export type MediaAccessLogUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MediaAccessLogCreateWithoutMediaInput, MediaAccessLogUncheckedCreateWithoutMediaInput> | MediaAccessLogCreateWithoutMediaInput[] | MediaAccessLogUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaAccessLogCreateOrConnectWithoutMediaInput | MediaAccessLogCreateOrConnectWithoutMediaInput[]
    upsert?: MediaAccessLogUpsertWithWhereUniqueWithoutMediaInput | MediaAccessLogUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MediaAccessLogCreateManyMediaInputEnvelope
    set?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
    disconnect?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
    delete?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
    connect?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
    update?: MediaAccessLogUpdateWithWhereUniqueWithoutMediaInput | MediaAccessLogUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MediaAccessLogUpdateManyWithWhereWithoutMediaInput | MediaAccessLogUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MediaAccessLogScalarWhereInput | MediaAccessLogScalarWhereInput[]
  }

  export type MediaShareUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MediaShareCreateWithoutMediaInput, MediaShareUncheckedCreateWithoutMediaInput> | MediaShareCreateWithoutMediaInput[] | MediaShareUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaShareCreateOrConnectWithoutMediaInput | MediaShareCreateOrConnectWithoutMediaInput[]
    upsert?: MediaShareUpsertWithWhereUniqueWithoutMediaInput | MediaShareUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MediaShareCreateManyMediaInputEnvelope
    set?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
    disconnect?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
    delete?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
    connect?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
    update?: MediaShareUpdateWithWhereUniqueWithoutMediaInput | MediaShareUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MediaShareUpdateManyWithWhereWithoutMediaInput | MediaShareUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MediaShareScalarWhereInput | MediaShareScalarWhereInput[]
  }

  export type MediaPreviewUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MediaPreviewCreateWithoutMediaInput, MediaPreviewUncheckedCreateWithoutMediaInput> | MediaPreviewCreateWithoutMediaInput[] | MediaPreviewUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaPreviewCreateOrConnectWithoutMediaInput | MediaPreviewCreateOrConnectWithoutMediaInput[]
    upsert?: MediaPreviewUpsertWithWhereUniqueWithoutMediaInput | MediaPreviewUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MediaPreviewCreateManyMediaInputEnvelope
    set?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
    disconnect?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
    delete?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
    connect?: MediaPreviewWhereUniqueInput | MediaPreviewWhereUniqueInput[]
    update?: MediaPreviewUpdateWithWhereUniqueWithoutMediaInput | MediaPreviewUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MediaPreviewUpdateManyWithWhereWithoutMediaInput | MediaPreviewUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MediaPreviewScalarWhereInput | MediaPreviewScalarWhereInput[]
  }

  export type MediaAccessLogUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MediaAccessLogCreateWithoutMediaInput, MediaAccessLogUncheckedCreateWithoutMediaInput> | MediaAccessLogCreateWithoutMediaInput[] | MediaAccessLogUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaAccessLogCreateOrConnectWithoutMediaInput | MediaAccessLogCreateOrConnectWithoutMediaInput[]
    upsert?: MediaAccessLogUpsertWithWhereUniqueWithoutMediaInput | MediaAccessLogUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MediaAccessLogCreateManyMediaInputEnvelope
    set?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
    disconnect?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
    delete?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
    connect?: MediaAccessLogWhereUniqueInput | MediaAccessLogWhereUniqueInput[]
    update?: MediaAccessLogUpdateWithWhereUniqueWithoutMediaInput | MediaAccessLogUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MediaAccessLogUpdateManyWithWhereWithoutMediaInput | MediaAccessLogUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MediaAccessLogScalarWhereInput | MediaAccessLogScalarWhereInput[]
  }

  export type MediaShareUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MediaShareCreateWithoutMediaInput, MediaShareUncheckedCreateWithoutMediaInput> | MediaShareCreateWithoutMediaInput[] | MediaShareUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaShareCreateOrConnectWithoutMediaInput | MediaShareCreateOrConnectWithoutMediaInput[]
    upsert?: MediaShareUpsertWithWhereUniqueWithoutMediaInput | MediaShareUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MediaShareCreateManyMediaInputEnvelope
    set?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
    disconnect?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
    delete?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
    connect?: MediaShareWhereUniqueInput | MediaShareWhereUniqueInput[]
    update?: MediaShareUpdateWithWhereUniqueWithoutMediaInput | MediaShareUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MediaShareUpdateManyWithWhereWithoutMediaInput | MediaShareUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MediaShareScalarWhereInput | MediaShareScalarWhereInput[]
  }

  export type MediaCreateNestedOneWithoutPreviewsInput = {
    create?: XOR<MediaCreateWithoutPreviewsInput, MediaUncheckedCreateWithoutPreviewsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPreviewsInput
    connect?: MediaWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MediaUpdateOneRequiredWithoutPreviewsNestedInput = {
    create?: XOR<MediaCreateWithoutPreviewsInput, MediaUncheckedCreateWithoutPreviewsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPreviewsInput
    upsert?: MediaUpsertWithoutPreviewsInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutPreviewsInput, MediaUpdateWithoutPreviewsInput>, MediaUncheckedUpdateWithoutPreviewsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MediaCreateNestedManyWithoutCategoryInput = {
    create?: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput> | MediaCreateWithoutCategoryInput[] | MediaUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutCategoryInput | MediaCreateOrConnectWithoutCategoryInput[]
    createMany?: MediaCreateManyCategoryInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput> | MediaCreateWithoutCategoryInput[] | MediaUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutCategoryInput | MediaCreateOrConnectWithoutCategoryInput[]
    createMany?: MediaCreateManyCategoryInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MediaUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput> | MediaCreateWithoutCategoryInput[] | MediaUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutCategoryInput | MediaCreateOrConnectWithoutCategoryInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutCategoryInput | MediaUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: MediaCreateManyCategoryInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutCategoryInput | MediaUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutCategoryInput | MediaUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput> | MediaCreateWithoutCategoryInput[] | MediaUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutCategoryInput | MediaCreateOrConnectWithoutCategoryInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutCategoryInput | MediaUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: MediaCreateManyCategoryInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutCategoryInput | MediaUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutCategoryInput | MediaUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type MediaCreateNestedOneWithoutAccessLogsInput = {
    create?: XOR<MediaCreateWithoutAccessLogsInput, MediaUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutAccessLogsInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaUpdateOneRequiredWithoutAccessLogsNestedInput = {
    create?: XOR<MediaCreateWithoutAccessLogsInput, MediaUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutAccessLogsInput
    upsert?: MediaUpsertWithoutAccessLogsInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutAccessLogsInput, MediaUpdateWithoutAccessLogsInput>, MediaUncheckedUpdateWithoutAccessLogsInput>
  }

  export type MediaCreateNestedOneWithoutSharesInput = {
    create?: XOR<MediaCreateWithoutSharesInput, MediaUncheckedCreateWithoutSharesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutSharesInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<MediaCreateWithoutSharesInput, MediaUncheckedCreateWithoutSharesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutSharesInput
    upsert?: MediaUpsertWithoutSharesInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutSharesInput, MediaUpdateWithoutSharesInput>, MediaUncheckedUpdateWithoutSharesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MediaCategoryCreateWithoutMediaInput = {
    id?: string
    name: string
    description?: string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize: bigint | number
    compressionEnabled?: boolean
    previewEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCategoryUncheckedCreateWithoutMediaInput = {
    id?: string
    name: string
    description?: string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize: bigint | number
    compressionEnabled?: boolean
    previewEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCategoryCreateOrConnectWithoutMediaInput = {
    where: MediaCategoryWhereUniqueInput
    create: XOR<MediaCategoryCreateWithoutMediaInput, MediaCategoryUncheckedCreateWithoutMediaInput>
  }

  export type MediaPreviewCreateWithoutMediaInput = {
    id?: string
    previewType: string
    storagePath: string
    contentType: string
    width?: number | null
    height?: number | null
    fileSize: bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaPreviewUncheckedCreateWithoutMediaInput = {
    id?: string
    previewType: string
    storagePath: string
    contentType: string
    width?: number | null
    height?: number | null
    fileSize: bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaPreviewCreateOrConnectWithoutMediaInput = {
    where: MediaPreviewWhereUniqueInput
    create: XOR<MediaPreviewCreateWithoutMediaInput, MediaPreviewUncheckedCreateWithoutMediaInput>
  }

  export type MediaPreviewCreateManyMediaInputEnvelope = {
    data: MediaPreviewCreateManyMediaInput | MediaPreviewCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type MediaAccessLogCreateWithoutMediaInput = {
    id?: string
    userId: string
    actionType: string
    clientIp?: string | null
    userAgent?: string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: Date | string
  }

  export type MediaAccessLogUncheckedCreateWithoutMediaInput = {
    id?: string
    userId: string
    actionType: string
    clientIp?: string | null
    userAgent?: string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: Date | string
  }

  export type MediaAccessLogCreateOrConnectWithoutMediaInput = {
    where: MediaAccessLogWhereUniqueInput
    create: XOR<MediaAccessLogCreateWithoutMediaInput, MediaAccessLogUncheckedCreateWithoutMediaInput>
  }

  export type MediaAccessLogCreateManyMediaInputEnvelope = {
    data: MediaAccessLogCreateManyMediaInput | MediaAccessLogCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type MediaShareCreateWithoutMediaInput = {
    id?: string
    sharedBy: string
    sharedWith: string
    permissionLevel: string
    sharedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type MediaShareUncheckedCreateWithoutMediaInput = {
    id?: string
    sharedBy: string
    sharedWith: string
    permissionLevel: string
    sharedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type MediaShareCreateOrConnectWithoutMediaInput = {
    where: MediaShareWhereUniqueInput
    create: XOR<MediaShareCreateWithoutMediaInput, MediaShareUncheckedCreateWithoutMediaInput>
  }

  export type MediaShareCreateManyMediaInputEnvelope = {
    data: MediaShareCreateManyMediaInput | MediaShareCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type MediaCategoryUpsertWithoutMediaInput = {
    update: XOR<MediaCategoryUpdateWithoutMediaInput, MediaCategoryUncheckedUpdateWithoutMediaInput>
    create: XOR<MediaCategoryCreateWithoutMediaInput, MediaCategoryUncheckedCreateWithoutMediaInput>
    where?: MediaCategoryWhereInput
  }

  export type MediaCategoryUpdateToOneWithWhereWithoutMediaInput = {
    where?: MediaCategoryWhereInput
    data: XOR<MediaCategoryUpdateWithoutMediaInput, MediaCategoryUncheckedUpdateWithoutMediaInput>
  }

  export type MediaCategoryUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    compressionEnabled?: BoolFieldUpdateOperationsInput | boolean
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCategoryUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    allowedTypes?: JsonNullValueInput | InputJsonValue
    maxFileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    compressionEnabled?: BoolFieldUpdateOperationsInput | boolean
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPreviewUpsertWithWhereUniqueWithoutMediaInput = {
    where: MediaPreviewWhereUniqueInput
    update: XOR<MediaPreviewUpdateWithoutMediaInput, MediaPreviewUncheckedUpdateWithoutMediaInput>
    create: XOR<MediaPreviewCreateWithoutMediaInput, MediaPreviewUncheckedCreateWithoutMediaInput>
  }

  export type MediaPreviewUpdateWithWhereUniqueWithoutMediaInput = {
    where: MediaPreviewWhereUniqueInput
    data: XOR<MediaPreviewUpdateWithoutMediaInput, MediaPreviewUncheckedUpdateWithoutMediaInput>
  }

  export type MediaPreviewUpdateManyWithWhereWithoutMediaInput = {
    where: MediaPreviewScalarWhereInput
    data: XOR<MediaPreviewUpdateManyMutationInput, MediaPreviewUncheckedUpdateManyWithoutMediaInput>
  }

  export type MediaPreviewScalarWhereInput = {
    AND?: MediaPreviewScalarWhereInput | MediaPreviewScalarWhereInput[]
    OR?: MediaPreviewScalarWhereInput[]
    NOT?: MediaPreviewScalarWhereInput | MediaPreviewScalarWhereInput[]
    id?: UuidFilter<"MediaPreview"> | string
    mediaId?: UuidFilter<"MediaPreview"> | string
    previewType?: StringFilter<"MediaPreview"> | string
    storagePath?: StringFilter<"MediaPreview"> | string
    contentType?: StringFilter<"MediaPreview"> | string
    width?: IntNullableFilter<"MediaPreview"> | number | null
    height?: IntNullableFilter<"MediaPreview"> | number | null
    fileSize?: BigIntFilter<"MediaPreview"> | bigint | number
    metadata?: JsonFilter<"MediaPreview">
    createdAt?: DateTimeFilter<"MediaPreview"> | Date | string
  }

  export type MediaAccessLogUpsertWithWhereUniqueWithoutMediaInput = {
    where: MediaAccessLogWhereUniqueInput
    update: XOR<MediaAccessLogUpdateWithoutMediaInput, MediaAccessLogUncheckedUpdateWithoutMediaInput>
    create: XOR<MediaAccessLogCreateWithoutMediaInput, MediaAccessLogUncheckedCreateWithoutMediaInput>
  }

  export type MediaAccessLogUpdateWithWhereUniqueWithoutMediaInput = {
    where: MediaAccessLogWhereUniqueInput
    data: XOR<MediaAccessLogUpdateWithoutMediaInput, MediaAccessLogUncheckedUpdateWithoutMediaInput>
  }

  export type MediaAccessLogUpdateManyWithWhereWithoutMediaInput = {
    where: MediaAccessLogScalarWhereInput
    data: XOR<MediaAccessLogUpdateManyMutationInput, MediaAccessLogUncheckedUpdateManyWithoutMediaInput>
  }

  export type MediaAccessLogScalarWhereInput = {
    AND?: MediaAccessLogScalarWhereInput | MediaAccessLogScalarWhereInput[]
    OR?: MediaAccessLogScalarWhereInput[]
    NOT?: MediaAccessLogScalarWhereInput | MediaAccessLogScalarWhereInput[]
    id?: UuidFilter<"MediaAccessLog"> | string
    mediaId?: UuidFilter<"MediaAccessLog"> | string
    userId?: UuidFilter<"MediaAccessLog"> | string
    actionType?: StringFilter<"MediaAccessLog"> | string
    clientIp?: StringNullableFilter<"MediaAccessLog"> | string | null
    userAgent?: StringNullableFilter<"MediaAccessLog"> | string | null
    requestMetadata?: JsonFilter<"MediaAccessLog">
    accessedAt?: DateTimeFilter<"MediaAccessLog"> | Date | string
  }

  export type MediaShareUpsertWithWhereUniqueWithoutMediaInput = {
    where: MediaShareWhereUniqueInput
    update: XOR<MediaShareUpdateWithoutMediaInput, MediaShareUncheckedUpdateWithoutMediaInput>
    create: XOR<MediaShareCreateWithoutMediaInput, MediaShareUncheckedCreateWithoutMediaInput>
  }

  export type MediaShareUpdateWithWhereUniqueWithoutMediaInput = {
    where: MediaShareWhereUniqueInput
    data: XOR<MediaShareUpdateWithoutMediaInput, MediaShareUncheckedUpdateWithoutMediaInput>
  }

  export type MediaShareUpdateManyWithWhereWithoutMediaInput = {
    where: MediaShareScalarWhereInput
    data: XOR<MediaShareUpdateManyMutationInput, MediaShareUncheckedUpdateManyWithoutMediaInput>
  }

  export type MediaShareScalarWhereInput = {
    AND?: MediaShareScalarWhereInput | MediaShareScalarWhereInput[]
    OR?: MediaShareScalarWhereInput[]
    NOT?: MediaShareScalarWhereInput | MediaShareScalarWhereInput[]
    id?: UuidFilter<"MediaShare"> | string
    mediaId?: UuidFilter<"MediaShare"> | string
    sharedBy?: UuidFilter<"MediaShare"> | string
    sharedWith?: UuidFilter<"MediaShare"> | string
    permissionLevel?: StringFilter<"MediaShare"> | string
    sharedAt?: DateTimeFilter<"MediaShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"MediaShare"> | Date | string | null
    isActive?: BoolFilter<"MediaShare"> | boolean
  }

  export type MediaCreateWithoutPreviewsInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    category: MediaCategoryCreateNestedOneWithoutMediaInput
    accessLogs?: MediaAccessLogCreateNestedManyWithoutMediaInput
    shares?: MediaShareCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutPreviewsInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    categoryId: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    accessLogs?: MediaAccessLogUncheckedCreateNestedManyWithoutMediaInput
    shares?: MediaShareUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutPreviewsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutPreviewsInput, MediaUncheckedCreateWithoutPreviewsInput>
  }

  export type MediaUpsertWithoutPreviewsInput = {
    update: XOR<MediaUpdateWithoutPreviewsInput, MediaUncheckedUpdateWithoutPreviewsInput>
    create: XOR<MediaCreateWithoutPreviewsInput, MediaUncheckedCreateWithoutPreviewsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutPreviewsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutPreviewsInput, MediaUncheckedUpdateWithoutPreviewsInput>
  }

  export type MediaUpdateWithoutPreviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: MediaCategoryUpdateOneRequiredWithoutMediaNestedInput
    accessLogs?: MediaAccessLogUpdateManyWithoutMediaNestedInput
    shares?: MediaShareUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutPreviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLogs?: MediaAccessLogUncheckedUpdateManyWithoutMediaNestedInput
    shares?: MediaShareUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateWithoutCategoryInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    previews?: MediaPreviewCreateNestedManyWithoutMediaInput
    accessLogs?: MediaAccessLogCreateNestedManyWithoutMediaInput
    shares?: MediaShareCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutCategoryInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    previews?: MediaPreviewUncheckedCreateNestedManyWithoutMediaInput
    accessLogs?: MediaAccessLogUncheckedCreateNestedManyWithoutMediaInput
    shares?: MediaShareUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutCategoryInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput>
  }

  export type MediaCreateManyCategoryInputEnvelope = {
    data: MediaCreateManyCategoryInput | MediaCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithWhereUniqueWithoutCategoryInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutCategoryInput, MediaUncheckedUpdateWithoutCategoryInput>
    create: XOR<MediaCreateWithoutCategoryInput, MediaUncheckedCreateWithoutCategoryInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutCategoryInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutCategoryInput, MediaUncheckedUpdateWithoutCategoryInput>
  }

  export type MediaUpdateManyWithWhereWithoutCategoryInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutCategoryInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: UuidFilter<"Media"> | string
    userId?: UuidFilter<"Media"> | string
    conversationId?: UuidNullableFilter<"Media"> | string | null
    messageId?: UuidNullableFilter<"Media"> | string | null
    originalFilename?: StringFilter<"Media"> | string
    contentType?: StringFilter<"Media"> | string
    fileSize?: BigIntFilter<"Media"> | bigint | number
    storagePath?: StringFilter<"Media"> | string
    encryptionKeyHash?: StringFilter<"Media"> | string
    moderationHash?: StringFilter<"Media"> | string
    categoryId?: UuidFilter<"Media"> | string
    metadata?: JsonFilter<"Media">
    exifData?: JsonFilter<"Media">
    isCompressed?: BoolFilter<"Media"> | boolean
    isActive?: BoolFilter<"Media"> | boolean
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Media"> | Date | string | null
  }

  export type MediaCreateWithoutAccessLogsInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    category: MediaCategoryCreateNestedOneWithoutMediaInput
    previews?: MediaPreviewCreateNestedManyWithoutMediaInput
    shares?: MediaShareCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutAccessLogsInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    categoryId: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    previews?: MediaPreviewUncheckedCreateNestedManyWithoutMediaInput
    shares?: MediaShareUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutAccessLogsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutAccessLogsInput, MediaUncheckedCreateWithoutAccessLogsInput>
  }

  export type MediaUpsertWithoutAccessLogsInput = {
    update: XOR<MediaUpdateWithoutAccessLogsInput, MediaUncheckedUpdateWithoutAccessLogsInput>
    create: XOR<MediaCreateWithoutAccessLogsInput, MediaUncheckedCreateWithoutAccessLogsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutAccessLogsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutAccessLogsInput, MediaUncheckedUpdateWithoutAccessLogsInput>
  }

  export type MediaUpdateWithoutAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: MediaCategoryUpdateOneRequiredWithoutMediaNestedInput
    previews?: MediaPreviewUpdateManyWithoutMediaNestedInput
    shares?: MediaShareUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previews?: MediaPreviewUncheckedUpdateManyWithoutMediaNestedInput
    shares?: MediaShareUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateWithoutSharesInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    category: MediaCategoryCreateNestedOneWithoutMediaInput
    previews?: MediaPreviewCreateNestedManyWithoutMediaInput
    accessLogs?: MediaAccessLogCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutSharesInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    categoryId: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    previews?: MediaPreviewUncheckedCreateNestedManyWithoutMediaInput
    accessLogs?: MediaAccessLogUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutSharesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutSharesInput, MediaUncheckedCreateWithoutSharesInput>
  }

  export type MediaUpsertWithoutSharesInput = {
    update: XOR<MediaUpdateWithoutSharesInput, MediaUncheckedUpdateWithoutSharesInput>
    create: XOR<MediaCreateWithoutSharesInput, MediaUncheckedCreateWithoutSharesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutSharesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutSharesInput, MediaUncheckedUpdateWithoutSharesInput>
  }

  export type MediaUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: MediaCategoryUpdateOneRequiredWithoutMediaNestedInput
    previews?: MediaPreviewUpdateManyWithoutMediaNestedInput
    accessLogs?: MediaAccessLogUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previews?: MediaPreviewUncheckedUpdateManyWithoutMediaNestedInput
    accessLogs?: MediaAccessLogUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaPreviewCreateManyMediaInput = {
    id?: string
    previewType: string
    storagePath: string
    contentType: string
    width?: number | null
    height?: number | null
    fileSize: bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaAccessLogCreateManyMediaInput = {
    id?: string
    userId: string
    actionType: string
    clientIp?: string | null
    userAgent?: string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: Date | string
  }

  export type MediaShareCreateManyMediaInput = {
    id?: string
    sharedBy: string
    sharedWith: string
    permissionLevel: string
    sharedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type MediaPreviewUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    previewType?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPreviewUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    previewType?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPreviewUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    previewType?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAccessLogUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAccessLogUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAccessLogUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    clientIp?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestMetadata?: JsonNullValueInput | InputJsonValue
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaShareUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissionLevel?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MediaShareUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissionLevel?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MediaShareUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharedBy?: StringFieldUpdateOperationsInput | string
    sharedWith?: StringFieldUpdateOperationsInput | string
    permissionLevel?: StringFieldUpdateOperationsInput | string
    sharedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MediaCreateManyCategoryInput = {
    id?: string
    userId: string
    conversationId?: string | null
    messageId?: string | null
    originalFilename: string
    contentType: string
    fileSize: bigint | number
    storagePath: string
    encryptionKeyHash: string
    moderationHash: string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type MediaUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previews?: MediaPreviewUpdateManyWithoutMediaNestedInput
    accessLogs?: MediaAccessLogUpdateManyWithoutMediaNestedInput
    shares?: MediaShareUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previews?: MediaPreviewUncheckedUpdateManyWithoutMediaNestedInput
    accessLogs?: MediaAccessLogUncheckedUpdateManyWithoutMediaNestedInput
    shares?: MediaShareUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    originalFilename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    storagePath?: StringFieldUpdateOperationsInput | string
    encryptionKeyHash?: StringFieldUpdateOperationsInput | string
    moderationHash?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    exifData?: JsonNullValueInput | InputJsonValue
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MediaCountOutputTypeDefaultArgs instead
     */
    export type MediaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaCategoryCountOutputTypeDefaultArgs instead
     */
    export type MediaCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaPreviewDefaultArgs instead
     */
    export type MediaPreviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaPreviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserQuotaDefaultArgs instead
     */
    export type UserQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaCategoryDefaultArgs instead
     */
    export type MediaCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaAccessLogDefaultArgs instead
     */
    export type MediaAccessLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaAccessLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaShareDefaultArgs instead
     */
    export type MediaShareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaShareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationHashDefaultArgs instead
     */
    export type ModerationHashArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationHashDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}